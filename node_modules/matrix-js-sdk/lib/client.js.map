{"version":3,"sources":["../src/client.js"],"names":["PushProcessor","require","EventEmitter","q","url","httpApi","MatrixEvent","EventStatus","EventTimeline","SearchResult","StubStore","webRtcCall","utils","contentRepo","Filter","SyncApi","MatrixBaseApis","MatrixError","SCROLLBACK_DELAY_MS","CRYPTO_ENABLED","Crypto","e","console","error","MatrixClient","opts","call","store","deviceId","userId","credentials","scheduler","self","setProcessFunction","eventToSend","room","getRoom","getRoomId","status","SENDING","_updatePendingEventStatus","_sendEventHttpRequest","clientRunning","callList","createNewMatrixCall","_supportsVoip","setupCallEventHandler","_syncingRetry","_syncApi","_peekSync","_isGuest","_ongoingScrollbacks","timelineSupport","Boolean","urlPreviewCache","_notifTimelineSet","_crypto","sessionStore","olmVersion","getOlmVersion","inherits","extend","prototype","getDomain","replace","getUserIdLocalpart","split","substring","getDeviceId","supportsVoip","getSyncState","isGuest","getScheduler","setGuest","retryImmediately","getNotifTimelineSet","setNotifTimelineSet","notifTimelineSet","isCryptoEnabled","getDeviceEd25519Key","uploadKeys","maxKeys","Error","downloadKeys","userIds","forceDownload","reject","listDeviceKeys","getStoredDevicesForUser","setDeviceVerified","verified","undefined","_setDeviceVerification","setDeviceBlocked","blocked","setDeviceKnown","known","client","dev","setDeviceVerification","emit","setGlobalBlacklistUnverifiedDevices","value","getGlobalBlacklistUnverifiedDevices","getEventSenderDeviceInfo","event","isEventSenderVerified","device","isVerified","setRoomEncryption","roomId","config","isRoomEncrypted","exportRoomKeys","importRoomKeys","keys","_decryptEvent","_badEncryptedMessage","decryptEvent","DecryptionError","message","reason","setClearData","type","content","msgtype","body","getRooms","getUser","getUsers","setAccountData","eventType","contents","callback","path","encodeUri","$userId","$type","_http","authedRequest","getAccountData","joinRoom","roomIdOrAlias","isFunction","syncRoom","hasMembershipState","sign_promise","inviteSignUrl","requestOtherUrl","mxid","defer","then","signed_invite_object","data","third_party_signed","$roomid","res","room_id","syncApi","_clientOpts","createRoom","done","_resolve","err","_reject","promise","resendEvent","_sendEvent","cancelPendingEvent","QUEUED","NOT_SENT","indexOf","removeEventFromQueue","CANCELLED","setRoomName","name","sendStateEvent","setRoomTopic","topic","getRoomTags","$roomId","setRoomTag","tagName","metadata","$tag","deleteRoomTag","setRoomAccountData","setPowerLevel","powerLevel","users","getType","deepCopy","getContent","sendEvent","txnId","makeTxnId","localEvent","event_id","user_id","origin_server_ts","Date","getTime","_txnId","addPendingEvent","encryptionPromise","encryptEventIfNeeded","ENCRYPTING","queueEvent","getQueueForEvent","length","updatePendingEvent","SENT","stack","err2","newStatus","pathParams","$eventType","getWireType","$stateKey","getStateKey","$txnId","isState","pathTemplate","getWireContent","sendMessage","sendTextMessage","sendNotice","sendEmoteMessage","sendImageMessage","info","text","sendHtmlMessage","htmlBody","format","formatted_body","sendHtmlNotice","sendHtmlEmote","sendReceipt","receiptType","$receiptType","$eventId","getId","_addLocalEchoReceipt","sendReadReceipt","getUrlPreview","ts","key","og","authedRequestWithPrefix","PREFIX_MEDIA_R0","response","sendTyping","isTyping","timeoutMs","typing","timeout","invite","_membershipChange","inviteByEmail","email","inviteByThreePid","medium","address","identityServerUrl","getIdentityServerUrl","errcode","id_server","leave","ban","forget","deleteRoom","removeRoom","unban","_setMembershipState","kick","membershipValue","membership","$room_id","$membership","getPushActionsForEvent","getPushActions","pushProcessor","setPushActions","actionsForEvent","setProfileInfo","$info","setDisplayName","displayname","setAvatarUrl","avatar_url","mxcUrlToHttp","mxcUrl","width","height","resizeMethod","allowDirectLinks","getHttpUriForMxc","baseUrl","setPresence","presence","validStates","_presenceList","method","getPresenceList","inviteToPresenceList","dropFromPresenceList","scrollback","limit","timeToWaitMs","errorTs","timeWaitedMs","now","Math","max","oldState","paginationToken","numAdded","params","from","dir","delay","matrixEvents","map","chunk","_PojoToMatrixEventMapper","addEventsToTimeline","getLiveTimeline","end","storeEvents","paginateEventContext","eventContext","backwards","token","getPaginateToken","pendingRequest","_paginateRequests","getEvent","getEventMapper","reverse","addEvents","setPaginateToken","finally","getEventTimeline","timelineSet","eventId","getTimelineForEvent","events_after","events","concat","events_before","timeline","addTimeline","initialiseState","state","getState","FORWARDS","start","tl","paginateEventTimeline","eventTimeline","isNotifTimeline","getTimelineSet","BACKWARDS","getPaginationToken","_paginationRequests","only","PREFIX_UNSTABLE","next_token","i","notifications","notification","actionListToActionsObject","actions","setPaginationToken","filter","getFilter","JSON","stringify","getRoomTimelineFilterComponent","resetNotifTimelineSet","resetLiveTimeline","peekInRoom","stopPeeking","peek","setGuestAccess","writePromise","guest_access","allowJoin","readPromise","allowRead","history_visibility","all","requestRegisterEmailToken","clientSecret","sendAttempt","nextLink","_requestTokenFromEndpoint","requestAdd3pidEmailToken","requestPasswordEmailToken","endpoint","id_server_url","parse","idBaseUrl","host","client_secret","send_attempt","next_link","request","getRoomPushRule","scope","pushRules","rule","rule_id","setRoomMutePushRule","mute","deferred","hasDontNotifyRule","roomPushRule","deletePushRule","addPushRule","resolve","ruleRefreshDeferred","getPushRules","result","searchMessageText","search","search_categories","room_events","search_term","query","searchRoomEvents","term","order_by","event_context","before_limit","after_limit","include_profile","searchResults","_query","results","highlights","_processRoomEventsSearch","bind","backPaginateRoomEventsSearch","next_batch","searchOpts","count","forEach","hl","Object","sr","fromJson","push","syncLeftRooms","_syncedLeftRooms","_syncLeftRoomsPromise","log","createFilter","filter_id","storeFilter","filterId","allowCached","$filterId","getOrCreateFilter","filterName","getFilterIdByName","existingFilter","oldDef","getDefinition","newDef","deepCompare","setFilterIdByName","httpStatus","existingId","createdFilter","getOpenIdToken","turnServer","getTurnServers","_turnServers","startClient","initialSyncLimit","tenMinutes","_uploadIntervalID","global","setInterval","checkTurnServers","stop","assign","crypto","sync","stopClient","clearInterval","clearTimeout","_checkTurnServersTimeoutID","candidatesByCall","callEventBuffer","isClientPrepared","on","ignoreCallIds","ev","call_id","callEventHandler","getSender","getAge","lifetime","callId","_initWithInvite","_gotRemoteIceCandidate","existingCall","existingCalls","values","thisCall","direction","_replacedBy","answer","hangup","_onAnsweredElsewhere","_receivedAnswer","candidates","_initWithHangup","_onHangupReceived","uris","ttl","servers","urls","username","credential","password","setTimeout","mapper","plainOldJsObject","isEncrypted","generateClientSecret","ret","chars","charAt","floor","random","module","exports"],"mappings":"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","file":"client.js","sourcesContent":["/*\nCopyright 2015, 2016 OpenMarket Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\"use strict\";\n\nconst PushProcessor = require('./pushprocessor');\n\n/**\n * This is an internal module. See {@link MatrixClient} for the public class.\n * @module client\n */\nconst EventEmitter = require(\"events\").EventEmitter;\nconst q = require(\"q\");\nconst url = require('url');\n\nconst httpApi = require(\"./http-api\");\nconst MatrixEvent = require(\"./models/event\").MatrixEvent;\nconst EventStatus = require(\"./models/event\").EventStatus;\nconst EventTimeline = require(\"./models/event-timeline\");\nconst SearchResult = require(\"./models/search-result\");\nconst StubStore = require(\"./store/stub\");\nconst webRtcCall = require(\"./webrtc/call\");\nconst utils = require(\"./utils\");\nconst contentRepo = require(\"./content-repo\");\nconst Filter = require(\"./filter\");\nconst SyncApi = require(\"./sync\");\nconst MatrixBaseApis = require(\"./base-apis\");\nconst MatrixError = httpApi.MatrixError;\n\nconst SCROLLBACK_DELAY_MS = 3000;\nlet CRYPTO_ENABLED = false;\n\ntry {\n    var Crypto = require(\"./crypto\");\n    CRYPTO_ENABLED = true;\n} catch (e) {\n    console.error(\"olm load error\", e);\n    // Olm not installed.\n}\n\n/**\n * Construct a Matrix Client. Only directly construct this if you want to use\n * custom modules. Normally, {@link createClient} should be used\n * as it specifies 'sensible' defaults for these modules.\n * @constructor\n * @extends {external:EventEmitter}\n * @extends {module:base-apis~MatrixBaseApis}\n *\n * @param {Object} opts The configuration options for this client.\n * @param {string} opts.baseUrl Required. The base URL to the client-server\n * HTTP API.\n * @param {string} opts.idBaseUrl Optional. The base identity server URL for\n * identity server requests.\n * @param {Function} opts.request Required. The function to invoke for HTTP\n * requests. The value of this property is typically <code>require(\"request\")\n * </code> as it returns a function which meets the required interface. See\n * {@link requestFunction} for more information.\n *\n * @param {string} opts.accessToken The access_token for this user.\n *\n * @param {string} opts.userId The user ID for this user.\n *\n * @param {Object=} opts.store The data store to use. If not specified,\n * this client will not store any HTTP responses.\n *\n * @param {string=} opts.deviceId A unique identifier for this device; used for\n *    tracking things like crypto keys and access tokens.  If not specified,\n *    end-to-end crypto will be disabled.\n *\n * @param {Object=} opts.sessionStore A store to be used for end-to-end crypto\n *    session data. This should be a {@link\n *    module:store/session/webstorage~WebStorageSessionStore|WebStorageSessionStore},\n *    or an object implementing the same interface. If not specified,\n *    end-to-end crypto will be disabled.\n *\n * @param {Object} opts.scheduler Optional. The scheduler to use. If not\n * specified, this client will not retry requests on failure. This client\n * will supply its own processing function to\n * {@link module:scheduler~MatrixScheduler#setProcessFunction}.\n *\n * @param {Object} opts.queryParams Optional. Extra query parameters to append\n * to all requests with this client. Useful for application services which require\n * <code>?user_id=</code>.\n *\n * @param {Number=} opts.localTimeoutMs Optional. The default maximum amount of\n * time to wait before timing out HTTP requests. If not specified, there is no timeout.\n *\n * @param {boolean} [opts.timelineSupport = false] Set to true to enable\n * improved timeline support ({@link\n * module:client~MatrixClient#getEventTimeline getEventTimeline}). It is\n * disabled by default for compatibility with older clients - in particular to\n * maintain support for back-paginating the live timeline after a '/sync'\n * result with a gap.\n */\nfunction MatrixClient(opts) {\n    MatrixBaseApis.call(this, opts);\n\n    this.store = opts.store || new StubStore();\n\n    this.deviceId = opts.deviceId || null;\n\n    const userId = (opts.userId || null);\n    this.credentials = {\n        userId: userId,\n    };\n\n    this.scheduler = opts.scheduler;\n    if (this.scheduler) {\n        const self = this;\n        this.scheduler.setProcessFunction(function(eventToSend) {\n            const room = self.getRoom(eventToSend.getRoomId());\n            if (eventToSend.status !== EventStatus.SENDING) {\n                _updatePendingEventStatus(room, eventToSend,\n                                          EventStatus.SENDING);\n            }\n            return _sendEventHttpRequest(self, eventToSend);\n        });\n    }\n    this.clientRunning = false;\n\n    this.callList = {\n        // callId: MatrixCall\n    };\n\n    // try constructing a MatrixCall to see if we are running in an environment\n    // which has WebRTC. If we are, listen for and handle m.call.* events.\n    const call = webRtcCall.createNewMatrixCall(this);\n    this._supportsVoip = false;\n    if (call) {\n        setupCallEventHandler(this);\n        this._supportsVoip = true;\n    }\n    this._syncingRetry = null;\n    this._syncApi = null;\n    this._peekSync = null;\n    this._isGuest = false;\n    this._ongoingScrollbacks = {};\n    this.timelineSupport = Boolean(opts.timelineSupport);\n    this.urlPreviewCache = {};\n    this._notifTimelineSet = null;\n\n    this._crypto = null;\n    if (CRYPTO_ENABLED && Boolean(opts.sessionStore) &&\n            userId !== null && this.deviceId !== null) {\n        this._crypto = new Crypto(\n            this, this,\n            opts.sessionStore,\n            userId, this.deviceId,\n            this.store,\n        );\n\n        this.olmVersion = Crypto.getOlmVersion();\n    }\n}\nutils.inherits(MatrixClient, EventEmitter);\nutils.extend(MatrixClient.prototype, MatrixBaseApis.prototype);\n\n/**\n * Get the domain for this client's MXID\n * @return {?string} Domain of this MXID\n */\nMatrixClient.prototype.getDomain = function() {\n    if (this.credentials && this.credentials.userId) {\n        return this.credentials.userId.replace(/^.*?:/, '');\n    }\n    return null;\n};\n\n/**\n * Get the local part of the current user ID e.g. \"foo\" in \"@foo:bar\".\n * @return {?string} The user ID localpart or null.\n */\nMatrixClient.prototype.getUserIdLocalpart = function() {\n    if (this.credentials && this.credentials.userId) {\n        return this.credentials.userId.split(\":\")[0].substring(1);\n    }\n    return null;\n};\n\n/**\n * Get the device ID of this client\n * @return {?string} device ID\n */\nMatrixClient.prototype.getDeviceId = function() {\n    return this.deviceId;\n};\n\n\n/**\n * Check if the runtime environment supports VoIP calling.\n * @return {boolean} True if VoIP is supported.\n */\nMatrixClient.prototype.supportsVoip = function() {\n    return this._supportsVoip;\n};\n\n/**\n * Get the current sync state.\n * @return {?string} the sync state, which may be null.\n * @see module:client~MatrixClient#event:\"sync\"\n */\nMatrixClient.prototype.getSyncState = function() {\n    if (!this._syncApi) {\n        return null;\n    }\n    return this._syncApi.getSyncState();\n};\n\n/**\n * Return whether the client is configured for a guest account.\n * @return {boolean} True if this is a guest access_token (or no token is supplied).\n */\nMatrixClient.prototype.isGuest = function() {\n    return this._isGuest;\n};\n\n/**\n * Return the provided scheduler, if any.\n * @return {?module:scheduler~MatrixScheduler} The scheduler or null\n */\nMatrixClient.prototype.getScheduler = function() {\n    return this.scheduler;\n};\n\n/**\n * Set whether this client is a guest account. <b>This method is experimental\n * and may change without warning.</b>\n * @param {boolean} isGuest True if this is a guest account.\n */\nMatrixClient.prototype.setGuest = function(isGuest) {\n    // EXPERIMENTAL:\n    // If the token is a macaroon, it should be encoded in it that it is a 'guest'\n    // access token, which means that the SDK can determine this entirely without\n    // the dev manually flipping this flag.\n    this._isGuest = isGuest;\n};\n\n/**\n * Retry a backed off syncing request immediately. This should only be used when\n * the user <b>explicitly</b> attempts to retry their lost connection.\n * @return {boolean} True if this resulted in a request being retried.\n */\nMatrixClient.prototype.retryImmediately = function() {\n    return this._syncApi.retryImmediately();\n};\n\n/**\n * Return the global notification EventTimelineSet, if any\n *\n * @return {EventTimelineSet} the globl notification EventTimelineSet\n */\nMatrixClient.prototype.getNotifTimelineSet = function() {\n    return this._notifTimelineSet;\n};\n\n/**\n * Set the global notification EventTimelineSet\n *\n * @param {EventTimelineSet} notifTimelineSet\n */\nMatrixClient.prototype.setNotifTimelineSet = function(notifTimelineSet) {\n    this._notifTimelineSet = notifTimelineSet;\n};\n\n// Crypto bits\n// ===========\n\n/**\n * Is end-to-end crypto enabled for this client.\n * @return {boolean} True if end-to-end is enabled.\n */\nMatrixClient.prototype.isCryptoEnabled = function() {\n    return this._crypto !== null;\n};\n\n\n/**\n * Get the Ed25519 key for this device\n *\n * @return {?string} base64-encoded ed25519 key. Null if crypto is\n *    disabled.\n */\nMatrixClient.prototype.getDeviceEd25519Key = function() {\n    if (!this._crypto) {\n        return null;\n    }\n    return this._crypto.getDeviceEd25519Key();\n};\n\n/**\n * Upload the device keys to the homeserver and ensure that the\n * homeserver has enough one-time keys.\n * @param {number} maxKeys The maximum number of keys to generate\n * @return {object} A promise that will resolve when the keys are uploaded.\n */\nMatrixClient.prototype.uploadKeys = function(maxKeys) {\n    if (this._crypto === null) {\n        throw new Error(\"End-to-end encryption disabled\");\n    }\n\n    return this._crypto.uploadKeys(maxKeys);\n};\n\n/**\n * Download the keys for a list of users and stores the keys in the session\n * store.\n * @param {Array} userIds The users to fetch.\n * @param {bool} forceDownload Always download the keys even if cached.\n *\n * @return {Promise} A promise which resolves to a map userId->deviceId->{@link\n * module:crypto~DeviceInfo|DeviceInfo}.\n */\nMatrixClient.prototype.downloadKeys = function(userIds, forceDownload) {\n    if (this._crypto === null) {\n        return q.reject(new Error(\"End-to-end encryption disabled\"));\n    }\n    return this._crypto.downloadKeys(userIds, forceDownload);\n};\n\n/**\n * List the stored device keys for a user id\n *\n * @deprecated prefer {@link module:client#getStoredDevicesForUser}\n *\n * @param {string} userId the user to list keys for.\n *\n * @return {object[]} list of devices with \"id\", \"verified\", \"blocked\",\n *    \"key\", and \"display_name\" parameters.\n */\nMatrixClient.prototype.listDeviceKeys = function(userId) {\n    if (this._crypto === null) {\n        throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this._crypto.listDeviceKeys(userId);\n};\n\n/**\n * Get the stored device keys for a user id\n *\n * @param {string} userId the user to list keys for.\n *\n * @return {module:crypto-deviceinfo[]} list of devices\n */\nMatrixClient.prototype.getStoredDevicesForUser = function(userId) {\n    if (this._crypto === null) {\n        throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this._crypto.getStoredDevicesForUser(userId) || [];\n};\n\n/**\n * Mark the given device as verified\n *\n * @param {string} userId owner of the device\n * @param {string} deviceId unique identifier for the device\n *\n * @param {boolean=} verified whether to mark the device as verified. defaults\n *   to 'true'.\n *\n * @fires module:client~event:MatrixClient\"deviceVerificationChanged\"\n */\nMatrixClient.prototype.setDeviceVerified = function(userId, deviceId, verified) {\n    if (verified === undefined) {\n        verified = true;\n    }\n    _setDeviceVerification(this, userId, deviceId, verified, null);\n};\n\n/**\n * Mark the given device as blocked/unblocked\n *\n * @param {string} userId owner of the device\n * @param {string} deviceId unique identifier for the device\n *\n * @param {boolean=} blocked whether to mark the device as blocked. defaults\n *   to 'true'.\n *\n * @fires module:client~event:MatrixClient\"deviceVerificationChanged\"\n */\nMatrixClient.prototype.setDeviceBlocked = function(userId, deviceId, blocked) {\n    if (blocked === undefined) {\n        blocked = true;\n    }\n    _setDeviceVerification(this, userId, deviceId, null, blocked);\n};\n\n/**\n * Mark the given device as known/unknown\n *\n * @param {string} userId owner of the device\n * @param {string} deviceId unique identifier for the device\n *\n * @param {boolean=} known whether to mark the device as known. defaults\n *   to 'true'.\n *\n * @fires module:client~event:MatrixClient\"deviceVerificationChanged\"\n */\nMatrixClient.prototype.setDeviceKnown = function(userId, deviceId, known) {\n    if (known === undefined) {\n        known = true;\n    }\n    _setDeviceVerification(this, userId, deviceId, null, null, known);\n};\n\nfunction _setDeviceVerification(client, userId, deviceId, verified, blocked, known) {\n    if (!client._crypto) {\n        throw new Error(\"End-to-End encryption disabled\");\n    }\n    const dev = client._crypto.setDeviceVerification(\n        userId, deviceId, verified, blocked, known,\n    );\n    client.emit(\"deviceVerificationChanged\", userId, deviceId, dev);\n}\n\n/**\n * Set the global override for whether the client should ever send encrypted\n * messages to unverified devices.  If false, it can still be overridden\n * per-room.  If true, it overrides the per-room settings.\n *\n * @param {boolean} value whether to unilaterally blacklist all\n * unverified devices\n */\nMatrixClient.prototype.setGlobalBlacklistUnverifiedDevices = function(value) {\n    if (this._crypto === null) {\n        throw new Error(\"End-to-end encryption disabled\");\n    }\n    this._crypto.setGlobalBlacklistUnverifiedDevices(value);\n};\n\n/**\n * @return {boolean} whether to unilaterally blacklist all\n * unverified devices\n */\nMatrixClient.prototype.getGlobalBlacklistUnverifiedDevices = function() {\n    if (this._crypto === null) {\n        throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this._crypto.getGlobalBlacklistUnverifiedDevices();\n};\n\n/**\n * Get e2e information on the device that sent an event\n *\n * @param {MatrixEvent} event event to be checked\n *\n * @return {module:crypto/deviceinfo?}\n */\nMatrixClient.prototype.getEventSenderDeviceInfo = function(event) {\n    if (!this._crypto) {\n        return null;\n    }\n\n    return this._crypto.getEventSenderDeviceInfo(event);\n};\n\n/**\n * Check if the sender of an event is verified\n *\n * @param {MatrixEvent} event event to be checked\n *\n * @return {boolean} true if the sender of this event has been verified using\n * {@link module:client~MatrixClient#setDeviceVerified|setDeviceVerified}.\n */\nMatrixClient.prototype.isEventSenderVerified = function(event) {\n    const device = this.getEventSenderDeviceInfo(event);\n    if (!device) {\n        return false;\n    }\n    return device.isVerified();\n};\n\n/**\n * Enable end-to-end encryption for a room.\n * @param {string} roomId The room ID to enable encryption in.\n * @param {object} config The encryption config for the room.\n * @return {Object} A promise that will resolve when encryption is setup.\n */\nMatrixClient.prototype.setRoomEncryption = function(roomId, config) {\n    if (!this._crypto) {\n        throw new Error(\"End-to-End encryption disabled\");\n    }\n    this._crypto.setRoomEncryption(roomId, config);\n    return q();\n};\n\n/**\n * Whether encryption is enabled for a room.\n * @param {string} roomId the room id to query.\n * @return {bool} whether encryption is enabled.\n */\nMatrixClient.prototype.isRoomEncrypted = function(roomId) {\n    if (!this._crypto) {\n        return false;\n    }\n\n    return this._crypto.isRoomEncrypted(roomId);\n};\n\n/**\n * Get a list containing all of the room keys\n *\n * This should be encrypted before returning it to the user.\n *\n * @return {module:client.Promise} a promise which resolves to a list of\n *    session export objects\n */\nMatrixClient.prototype.exportRoomKeys = function() {\n    if (!this._crypto) {\n        return q.reject(new Error(\"End-to-end encryption disabled\"));\n    }\n    return this._crypto.exportRoomKeys();\n};\n\n/**\n * Import a list of room keys previously exported by exportRoomKeys\n *\n * @param {Object[]} keys a list of session export objects\n */\nMatrixClient.prototype.importRoomKeys = function(keys) {\n    if (!this._crypto) {\n        throw new Error(\"End-to-end encryption disabled\");\n    }\n    this._crypto.importRoomKeys(keys);\n};\n\n/**\n * Decrypt a received event according to the algorithm specified in the event.\n *\n * @param {MatrixClient} client\n * @param {MatrixEvent} event\n */\nfunction _decryptEvent(client, event) {\n    if (!client._crypto) {\n        _badEncryptedMessage(event, \"Encryption not enabled\");\n        return;\n    }\n\n    try {\n        client._crypto.decryptEvent(event);\n    } catch (e) {\n        if (!(e instanceof Crypto.DecryptionError)) {\n            throw e;\n        }\n        _badEncryptedMessage(event, e.message);\n        return;\n    }\n}\n\nfunction _badEncryptedMessage(event, reason) {\n    event.setClearData({\n        type: \"m.room.message\",\n        content: {\n            msgtype: \"m.bad.encrypted\",\n            body: \"** Unable to decrypt: \" + reason + \" **\",\n        },\n    });\n}\n\n// Room ops\n// ========\n\n/**\n * Get the room for the given room ID.\n * This function will return a valid room for any room for which a Room event\n * has been emitted. Note in particular that other events, eg. RoomState.members\n * will be emitted for a room before this function will return the given room.\n * @param {string} roomId The room ID\n * @return {Room} The Room or null if it doesn't exist or there is no data store.\n */\nMatrixClient.prototype.getRoom = function(roomId) {\n    return this.store.getRoom(roomId);\n};\n\n/**\n * Retrieve all known rooms.\n * @return {Room[]} A list of rooms, or an empty list if there is no data store.\n */\nMatrixClient.prototype.getRooms = function() {\n    return this.store.getRooms();\n};\n\n/**\n * Retrieve a user.\n * @param {string} userId The user ID to retrieve.\n * @return {?User} A user or null if there is no data store or the user does\n * not exist.\n */\nMatrixClient.prototype.getUser = function(userId) {\n    return this.store.getUser(userId);\n};\n\n/**\n * Retrieve all known users.\n * @return {User[]} A list of users, or an empty list if there is no data store.\n */\nMatrixClient.prototype.getUsers = function() {\n    return this.store.getUsers();\n};\n\n// User Account Data operations\n// ============================\n\n/**\n * Set account data event for the current user.\n * @param {string} eventType The event type\n * @param {Object} contents the contents object for the event\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.setAccountData = function(eventType, contents, callback) {\n    const path = utils.encodeUri(\"/user/$userId/account_data/$type\", {\n        $userId: this.credentials.userId,\n        $type: eventType,\n    });\n    return this._http.authedRequest(\n        callback, \"PUT\", path, undefined, contents,\n    );\n};\n\n/**\n * Get account data event of given type for the current user.\n * @param {string} eventType The event type\n * @param {module:client.callback} callback Optional.\n * @return {?object} The contents of the given account data event\n */\nMatrixClient.prototype.getAccountData = function(eventType) {\n    return this.store.getAccountData(eventType);\n};\n\n// Room operations\n// ===============\n\n/**\n * Join a room. If you have already joined the room, this will no-op.\n * @param {string} roomIdOrAlias The room ID or room alias to join.\n * @param {Object} opts Options when joining the room.\n * @param {boolean} opts.syncRoom True to do a room initial sync on the resulting\n * room. If false, the <strong>returned Room object will have no current state.\n * </strong> Default: true.\n * @param {boolean} opts.inviteSignUrl If the caller has a keypair 3pid invite,\n *                                     the signing URL is passed in this parameter.\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: Room object.\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.joinRoom = function(roomIdOrAlias, opts, callback) {\n    // to help people when upgrading..\n    if (utils.isFunction(opts)) {\n        throw new Error(\"Expected 'opts' object, got function.\");\n    }\n    opts = opts || {};\n    if (opts.syncRoom === undefined) {\n        opts.syncRoom = true;\n    }\n\n    const room = this.getRoom(roomIdOrAlias);\n    if (room && room.hasMembershipState(this.credentials.userId, \"join\")) {\n        return q(room);\n    }\n\n    let sign_promise = q();\n\n    if (opts.inviteSignUrl) {\n        sign_promise = this._http.requestOtherUrl(\n            undefined, 'POST',\n            opts.inviteSignUrl, { mxid: this.credentials.userId },\n        );\n    }\n\n    const defer = q.defer();\n\n    const self = this;\n    sign_promise.then(function(signed_invite_object) {\n        const data = {};\n        if (signed_invite_object) {\n            data.third_party_signed = signed_invite_object;\n        }\n\n        const path = utils.encodeUri(\"/join/$roomid\", { $roomid: roomIdOrAlias});\n        return self._http.authedRequest(undefined, \"POST\", path, undefined, data);\n    }).then(function(res) {\n        const roomId = res.room_id;\n        const syncApi = new SyncApi(self, self._clientOpts);\n        const room = syncApi.createRoom(roomId);\n        if (opts.syncRoom) {\n            // v2 will do this for us\n            // return syncApi.syncRoom(room);\n        }\n        return q(room);\n    }).done(function(room) {\n        _resolve(callback, defer, room);\n    }, function(err) {\n        _reject(callback, defer, err);\n    });\n    return defer.promise;\n};\n\n/**\n * Resend an event.\n * @param {MatrixEvent} event The event to resend.\n * @param {Room} room Optional. The room the event is in. Will update the\n * timeline entry if provided.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.resendEvent = function(event, room) {\n    _updatePendingEventStatus(room, event, EventStatus.SENDING);\n    return _sendEvent(this, room, event);\n};\n\n/**\n * Cancel a queued or unsent event.\n *\n * @param {MatrixEvent} event   Event to cancel\n * @throws Error if the event is not in QUEUED or NOT_SENT state\n */\nMatrixClient.prototype.cancelPendingEvent = function(event) {\n    if ([EventStatus.QUEUED, EventStatus.NOT_SENT].indexOf(event.status) < 0) {\n        throw new Error(\"cannot cancel an event with status \" + event.status);\n    }\n\n    // first tell the scheduler to forget about it, if it's queued\n    if (this.scheduler) {\n        this.scheduler.removeEventFromQueue(event);\n    }\n\n    // then tell the room about the change of state, which will remove it\n    // from the room's list of pending events.\n    const room = this.getRoom(event.getRoomId());\n    _updatePendingEventStatus(room, event, EventStatus.CANCELLED);\n};\n\n/**\n * @param {string} roomId\n * @param {string} name\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.setRoomName = function(roomId, name, callback) {\n    return this.sendStateEvent(roomId, \"m.room.name\", {name: name},\n                               undefined, callback);\n};\n\n/**\n * @param {string} roomId\n * @param {string} topic\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.setRoomTopic = function(roomId, topic, callback) {\n    return this.sendStateEvent(roomId, \"m.room.topic\", {topic: topic},\n                               undefined, callback);\n};\n\n/**\n * @param {string} roomId\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.getRoomTags = function(roomId, callback) {\n    const path = utils.encodeUri(\"/user/$userId/rooms/$roomId/tags/\", {\n        $userId: this.credentials.userId,\n        $roomId: roomId,\n    });\n    return this._http.authedRequest(\n        callback, \"GET\", path, undefined,\n    );\n};\n\n/**\n * @param {string} roomId\n * @param {string} tagName name of room tag to be set\n * @param {object} metadata associated with that tag to be stored\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.setRoomTag = function(roomId, tagName, metadata, callback) {\n    const path = utils.encodeUri(\"/user/$userId/rooms/$roomId/tags/$tag\", {\n        $userId: this.credentials.userId,\n        $roomId: roomId,\n        $tag: tagName,\n    });\n    return this._http.authedRequest(\n        callback, \"PUT\", path, undefined, metadata,\n    );\n};\n\n/**\n * @param {string} roomId\n * @param {string} tagName name of room tag to be removed\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.deleteRoomTag = function(roomId, tagName, callback) {\n    const path = utils.encodeUri(\"/user/$userId/rooms/$roomId/tags/$tag\", {\n        $userId: this.credentials.userId,\n        $roomId: roomId,\n        $tag: tagName,\n    });\n    return this._http.authedRequest(\n        callback, \"DELETE\", path, undefined, undefined,\n    );\n};\n\n/**\n * @param {string} roomId\n * @param {string} eventType event type to be set\n * @param {object} content event content\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.setRoomAccountData = function(roomId, eventType,\n                                                     content, callback) {\n    const path = utils.encodeUri(\"/user/$userId/rooms/$roomId/account_data/$type\", {\n        $userId: this.credentials.userId,\n        $roomId: roomId,\n        $type: eventType,\n    });\n    return this._http.authedRequest(\n        callback, \"PUT\", path, undefined, content,\n    );\n};\n\n/**\n * Set a user's power level.\n * @param {string} roomId\n * @param {string} userId\n * @param {Number} powerLevel\n * @param {MatrixEvent} event\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.setPowerLevel = function(roomId, userId, powerLevel,\n                                                event, callback) {\n    let content = {\n        users: {},\n    };\n    if (event && event.getType() === \"m.room.power_levels\") {\n        // take a copy of the content to ensure we don't corrupt\n        // existing client state with a failed power level change\n        content = utils.deepCopy(event.getContent());\n    }\n    content.users[userId] = powerLevel;\n    const path = utils.encodeUri(\"/rooms/$roomId/state/m.room.power_levels\", {\n        $roomId: roomId,\n    });\n    return this._http.authedRequest(\n        callback, \"PUT\", path, undefined, content,\n    );\n};\n\n/**\n * @param {string} roomId\n * @param {string} eventType\n * @param {Object} content\n * @param {string} txnId Optional.\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.sendEvent = function(roomId, eventType, content, txnId,\n                                            callback) {\n    if (utils.isFunction(txnId)) {\n        callback = txnId; txnId = undefined;\n    }\n\n    if (!txnId) {\n        txnId = this.makeTxnId();\n    }\n\n    // we always construct a MatrixEvent when sending because the store and\n    // scheduler use them. We'll extract the params back out if it turns out\n    // the client has no scheduler or store.\n    const room = this.getRoom(roomId);\n    const localEvent = new MatrixEvent({\n        event_id: \"~\" + roomId + \":\" + txnId,\n        user_id: this.credentials.userId,\n        room_id: roomId,\n        type: eventType,\n        origin_server_ts: new Date().getTime(),\n        content: content,\n    });\n    localEvent._txnId = txnId;\n    localEvent.status = EventStatus.SENDING;\n\n    // add this event immediately to the local store as 'sending'.\n    if (room) {\n        room.addPendingEvent(localEvent, txnId);\n    }\n\n    return _sendEvent(this, room, localEvent, callback);\n};\n\n\n// encrypts the event if necessary\n// adds the event to the queue, or sends it\n// marks the event as sent/unsent\n// returns a promise which resolves with the result of the send request\nfunction _sendEvent(client, room, event, callback) {\n    // Add an extra q() to turn synchronous exceptions into promise rejections,\n    // so that we can handle synchronous and asynchronous exceptions with the\n    // same code path.\n    return q().then(function() {\n        let encryptionPromise = null;\n        if (client._crypto) {\n            encryptionPromise = client._crypto.encryptEventIfNeeded(event, room);\n        }\n        if (encryptionPromise) {\n            _updatePendingEventStatus(room, event, EventStatus.ENCRYPTING);\n            encryptionPromise = encryptionPromise.then(function() {\n                _updatePendingEventStatus(room, event, EventStatus.SENDING);\n            });\n        }\n        return encryptionPromise;\n    }).then(function() {\n        let promise;\n        // this event may be queued\n        if (client.scheduler) {\n            // if this returns a promsie then the scheduler has control now and will\n            // resolve/reject when it is done. Internally, the scheduler will invoke\n            // processFn which is set to this._sendEventHttpRequest so the same code\n            // path is executed regardless.\n            promise = client.scheduler.queueEvent(event);\n            if (promise && client.scheduler.getQueueForEvent(event).length > 1) {\n                // event is processed FIFO so if the length is 2 or more we know\n                // this event is stuck behind an earlier event.\n                _updatePendingEventStatus(room, event, EventStatus.QUEUED);\n            }\n        }\n\n        if (!promise) {\n            promise = _sendEventHttpRequest(client, event);\n        }\n        return promise;\n    }).then(function(res) {  // the request was sent OK\n        if (room) {\n            room.updatePendingEvent(event, EventStatus.SENT, res.event_id);\n        }\n        if (callback) {\n            callback(null, res);\n        }\n        return res;\n    }, function(err) {\n        // the request failed to send.\n        console.error(\"Error sending event\", err.stack || err);\n\n        try {\n            _updatePendingEventStatus(room, event, EventStatus.NOT_SENT);\n            event.error = err;\n\n            if (callback) {\n                callback(err);\n            }\n        } catch (err2) {\n            console.error(\"Exception in error handler!\", err2.stack || err);\n        }\n        throw err;\n    });\n}\n\nfunction _updatePendingEventStatus(room, event, newStatus) {\n    if (room) {\n        room.updatePendingEvent(event, newStatus);\n    } else {\n        event.status = newStatus;\n    }\n}\n\nfunction _sendEventHttpRequest(client, event) {\n    const txnId = event._txnId ? event._txnId : client.makeTxnId();\n\n    const pathParams = {\n        $roomId: event.getRoomId(),\n        $eventType: event.getWireType(),\n        $stateKey: event.getStateKey(),\n        $txnId: txnId,\n    };\n\n    let path;\n\n    if (event.isState()) {\n        let pathTemplate = \"/rooms/$roomId/state/$eventType\";\n        if (event.getStateKey() && event.getStateKey().length > 0) {\n            pathTemplate = \"/rooms/$roomId/state/$eventType/$stateKey\";\n        }\n        path = utils.encodeUri(pathTemplate, pathParams);\n    } else {\n        path = utils.encodeUri(\n            \"/rooms/$roomId/send/$eventType/$txnId\", pathParams,\n        );\n    }\n\n    return client._http.authedRequest(\n        undefined, \"PUT\", path, undefined, event.getWireContent(),\n    );\n}\n\n/**\n * @param {string} roomId\n * @param {Object} content\n * @param {string} txnId Optional.\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.sendMessage = function(roomId, content, txnId, callback) {\n    if (utils.isFunction(txnId)) {\n        callback = txnId; txnId = undefined;\n    }\n    return this.sendEvent(\n        roomId, \"m.room.message\", content, txnId, callback,\n    );\n};\n\n/**\n * @param {string} roomId\n * @param {string} body\n * @param {string} txnId Optional.\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.sendTextMessage = function(roomId, body, txnId, callback) {\n    const content = {\n         msgtype: \"m.text\",\n         body: body,\n    };\n    return this.sendMessage(roomId, content, txnId, callback);\n};\n\n/**\n * @param {string} roomId\n * @param {string} body\n * @param {string} txnId Optional.\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.sendNotice = function(roomId, body, txnId, callback) {\n    const content = {\n         msgtype: \"m.notice\",\n         body: body,\n    };\n    return this.sendMessage(roomId, content, txnId, callback);\n};\n\n/**\n * @param {string} roomId\n * @param {string} body\n * @param {string} txnId Optional.\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.sendEmoteMessage = function(roomId, body, txnId, callback) {\n    const content = {\n         msgtype: \"m.emote\",\n         body: body,\n    };\n    return this.sendMessage(roomId, content, txnId, callback);\n};\n\n/**\n * @param {string} roomId\n * @param {string} url\n * @param {Object} info\n * @param {string} text\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.sendImageMessage = function(roomId, url, info, text, callback) {\n    if (utils.isFunction(text)) {\n        callback = text; text = undefined;\n    }\n    if (!text) {\n        text = \"Image\";\n    }\n    const content = {\n         msgtype: \"m.image\",\n         url: url,\n         info: info,\n         body: text,\n    };\n    return this.sendMessage(roomId, content, callback);\n};\n\n/**\n * @param {string} roomId\n * @param {string} body\n * @param {string} htmlBody\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.sendHtmlMessage = function(roomId, body, htmlBody, callback) {\n    const content = {\n        msgtype: \"m.text\",\n        format: \"org.matrix.custom.html\",\n        body: body,\n        formatted_body: htmlBody,\n    };\n    return this.sendMessage(roomId, content, callback);\n};\n\n/**\n * @param {string} roomId\n * @param {string} body\n * @param {string} htmlBody\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.sendHtmlNotice = function(roomId, body, htmlBody, callback) {\n    const content = {\n        msgtype: \"m.notice\",\n        format: \"org.matrix.custom.html\",\n        body: body,\n        formatted_body: htmlBody,\n    };\n    return this.sendMessage(roomId, content, callback);\n};\n\n/**\n * @param {string} roomId\n * @param {string} body\n * @param {string} htmlBody\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.sendHtmlEmote = function(roomId, body, htmlBody, callback) {\n    const content = {\n        msgtype: \"m.emote\",\n        format: \"org.matrix.custom.html\",\n        body: body,\n        formatted_body: htmlBody,\n    };\n    return this.sendMessage(roomId, content, callback);\n};\n\n/**\n * Send a receipt.\n * @param {Event} event The event being acknowledged\n * @param {string} receiptType The kind of receipt e.g. \"m.read\"\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.sendReceipt = function(event, receiptType, callback) {\n    if (this.isGuest()) {\n        return q({}); // guests cannot send receipts so don't bother.\n    }\n\n    const path = utils.encodeUri(\"/rooms/$roomId/receipt/$receiptType/$eventId\", {\n        $roomId: event.getRoomId(),\n        $receiptType: receiptType,\n        $eventId: event.getId(),\n    });\n    const promise = this._http.authedRequest(\n        callback, \"POST\", path, undefined, {},\n    );\n\n    const room = this.getRoom(event.getRoomId());\n    if (room) {\n        room._addLocalEchoReceipt(this.credentials.userId, event, receiptType);\n    }\n    return promise;\n};\n\n/**\n * Send a read receipt.\n * @param {Event} event The event that has been read.\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.sendReadReceipt = function(event, callback) {\n    return this.sendReceipt(event, \"m.read\", callback);\n};\n\n\n/**\n * Get a preview of the given URL as of (roughly) the given point in time,\n * described as an object with OpenGraph keys and associated values.\n * Attributes may be synthesized where actual OG metadata is lacking.\n * Caches results to prevent hammering the server.\n * @param {string} url The URL to get preview data for\n * @param {Number} ts The preferred point in time that the preview should\n * describe (ms since epoch).  The preview returned will either be the most\n * recent one preceding this timestamp if available, or failing that the next\n * most recent available preview.\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: Object of OG metadata.\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n * May return synthesized attributes if the URL lacked OG meta.\n */\nMatrixClient.prototype.getUrlPreview = function(url, ts, callback) {\n    const key = ts + \"_\" + url;\n    const og = this.urlPreviewCache[key];\n    if (og) {\n        return q(og);\n    }\n\n    const self = this;\n    return this._http.authedRequestWithPrefix(\n        callback, \"GET\", \"/preview_url\", {\n            url: url,\n            ts: ts,\n        }, undefined, httpApi.PREFIX_MEDIA_R0,\n    ).then(function(response) {\n        // TODO: expire cache occasionally\n        self.urlPreviewCache[key] = response;\n        return response;\n    });\n};\n\n/**\n * @param {string} roomId\n * @param {boolean} isTyping\n * @param {Number} timeoutMs\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.sendTyping = function(roomId, isTyping, timeoutMs, callback) {\n    if (this.isGuest()) {\n        return q({}); // guests cannot send typing notifications so don't bother.\n    }\n\n    const path = utils.encodeUri(\"/rooms/$roomId/typing/$userId\", {\n        $roomId: roomId,\n        $userId: this.credentials.userId,\n    });\n    const data = {\n        typing: isTyping,\n    };\n    if (isTyping) {\n        data.timeout = timeoutMs ? timeoutMs : 20000;\n    }\n    return this._http.authedRequest(\n        callback, \"PUT\", path, undefined, data,\n    );\n};\n\n/**\n * @param {string} roomId\n * @param {string} userId\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.invite = function(roomId, userId, callback) {\n    return _membershipChange(this, roomId, userId, \"invite\", undefined,\n        callback);\n};\n\n/**\n * Invite a user to a room based on their email address.\n * @param {string} roomId The room to invite the user to.\n * @param {string} email The email address to invite.\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.inviteByEmail = function(roomId, email, callback) {\n    return this.inviteByThreePid(\n        roomId, \"email\", email, callback,\n    );\n};\n\n/**\n * Invite a user to a room based on a third-party identifier.\n * @param {string} roomId The room to invite the user to.\n * @param {string} medium The medium to invite the user e.g. \"email\".\n * @param {string} address The address for the specified medium.\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.inviteByThreePid = function(roomId, medium, address, callback) {\n    const path = utils.encodeUri(\n        \"/rooms/$roomId/invite\",\n        { $roomId: roomId },\n    );\n\n    let identityServerUrl = this.getIdentityServerUrl();\n    if (!identityServerUrl) {\n        return q.reject(new MatrixError({\n            error: \"No supplied identity server URL\",\n            errcode: \"ORG.MATRIX.JSSDK_MISSING_PARAM\",\n        }));\n    }\n    if (identityServerUrl.indexOf(\"http://\") === 0 ||\n            identityServerUrl.indexOf(\"https://\") === 0) {\n        // this request must not have the protocol part because reasons\n        identityServerUrl = identityServerUrl.split(\"://\")[1];\n    }\n\n    return this._http.authedRequest(callback, \"POST\", path, undefined, {\n        id_server: identityServerUrl,\n        medium: medium,\n        address: address,\n    });\n};\n\n/**\n * @param {string} roomId\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.leave = function(roomId, callback) {\n    return _membershipChange(this, roomId, undefined, \"leave\", undefined,\n        callback);\n};\n\n/**\n * @param {string} roomId\n * @param {string} userId\n * @param {string} reason Optional.\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.ban = function(roomId, userId, reason, callback) {\n    return _membershipChange(this, roomId, userId, \"ban\", reason,\n        callback);\n};\n\n/**\n * @param {string} roomId\n * @param {boolean} deleteRoom True to delete the room from the store on success.\n * Default: true.\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.forget = function(roomId, deleteRoom, callback) {\n    if (deleteRoom === undefined) {\n        deleteRoom = true;\n    }\n    const promise = _membershipChange(this, roomId, undefined, \"forget\", undefined,\n        callback);\n    if (!deleteRoom) {\n        return promise;\n    }\n    const self = this;\n    return promise.then(function(response) {\n        self.store.removeRoom(roomId);\n        self.emit(\"deleteRoom\", roomId);\n        return response;\n    });\n};\n\n/**\n * @param {string} roomId\n * @param {string} userId\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.unban = function(roomId, userId, callback) {\n    // unbanning = set their state to leave\n    return _setMembershipState(\n        this, roomId, userId, \"leave\", undefined, callback,\n    );\n};\n\n/**\n * @param {string} roomId\n * @param {string} userId\n * @param {string} reason Optional.\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.kick = function(roomId, userId, reason, callback) {\n    return _setMembershipState(\n        this, roomId, userId, \"leave\", reason, callback,\n    );\n};\n\n/**\n * This is an internal method.\n * @param {MatrixClient} client\n * @param {string} roomId\n * @param {string} userId\n * @param {string} membershipValue\n * @param {string} reason\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nfunction _setMembershipState(client, roomId, userId, membershipValue, reason,\n                             callback) {\n    if (utils.isFunction(reason)) {\n        callback = reason; reason = undefined;\n    }\n\n    const path = utils.encodeUri(\n        \"/rooms/$roomId/state/m.room.member/$userId\",\n        { $roomId: roomId, $userId: userId},\n    );\n\n    return client._http.authedRequest(callback, \"PUT\", path, undefined, {\n        membership: membershipValue,\n        reason: reason,\n    });\n}\n\n/**\n * This is an internal method.\n * @param {MatrixClient} client\n * @param {string} roomId\n * @param {string} userId\n * @param {string} membership\n * @param {string} reason\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nfunction _membershipChange(client, roomId, userId, membership, reason, callback) {\n    if (utils.isFunction(reason)) {\n        callback = reason; reason = undefined;\n    }\n\n    const path = utils.encodeUri(\"/rooms/$room_id/$membership\", {\n        $room_id: roomId,\n        $membership: membership,\n    });\n    return client._http.authedRequest(\n        callback, \"POST\", path, undefined, {\n            user_id: userId,  // may be undefined e.g. on leave\n            reason: reason,\n        },\n    );\n}\n\n/**\n * Obtain a dict of actions which should be performed for this event according\n * to the push rules for this user.  Caches the dict on the event.\n * @param {MatrixEvent} event The event to get push actions for.\n * @return {module:pushprocessor~PushAction} A dict of actions to perform.\n */\nMatrixClient.prototype.getPushActionsForEvent = function(event) {\n    if (!event.getPushActions()) {\n        const pushProcessor = new PushProcessor(this);\n        event.setPushActions(pushProcessor.actionsForEvent(event));\n    }\n    return event.getPushActions();\n};\n\n// Profile operations\n// ==================\n\n/**\n * @param {string} info The kind of info to set (e.g. 'avatar_url')\n * @param {Object} data The JSON object to set.\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.setProfileInfo = function(info, data, callback) {\n    const path = utils.encodeUri(\"/profile/$userId/$info\", {\n        $userId: this.credentials.userId,\n        $info: info,\n    });\n    return this._http.authedRequest(\n        callback, \"PUT\", path, undefined, data,\n    );\n};\n\n/**\n * @param {string} name\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.setDisplayName = function(name, callback) {\n    return this.setProfileInfo(\n        \"displayname\", { displayname: name }, callback,\n    );\n};\n\n/**\n * @param {string} url\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.setAvatarUrl = function(url, callback) {\n    return this.setProfileInfo(\n        \"avatar_url\", { avatar_url: url }, callback,\n    );\n};\n\n/**\n * Turn an MXC URL into an HTTP one. <strong>This method is experimental and\n * may change.</strong>\n * @param {string} mxcUrl The MXC URL\n * @param {Number} width The desired width of the thumbnail.\n * @param {Number} height The desired height of the thumbnail.\n * @param {string} resizeMethod The thumbnail resize method to use, either\n * \"crop\" or \"scale\".\n * @param {Boolean} allowDirectLinks If true, return any non-mxc URLs\n * directly. Fetching such URLs will leak information about the user to\n * anyone they share a room with. If false, will return null for such URLs.\n * @return {?string} the avatar URL or null.\n */\nMatrixClient.prototype.mxcUrlToHttp =\n        function(mxcUrl, width, height, resizeMethod, allowDirectLinks) {\n    return contentRepo.getHttpUriForMxc(\n        this.baseUrl, mxcUrl, width, height, resizeMethod, allowDirectLinks,\n    );\n};\n\n/**\n * @param {Object} opts Options to apply\n * @param {string} opts.presence One of \"online\", \"offline\" or \"unavailable\"\n * @param {string} opts.status_msg The status message to attach.\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n * @throws If 'presence' isn't a valid presence enum value.\n */\nMatrixClient.prototype.setPresence = function(opts, callback) {\n    const path = utils.encodeUri(\"/presence/$userId/status\", {\n        $userId: this.credentials.userId,\n    });\n\n    if (typeof opts === \"string\") {\n      opts = { presence: opts };\n    }\n\n    const validStates = [\"offline\", \"online\", \"unavailable\"];\n    if (validStates.indexOf(opts.presence) == -1) {\n        throw new Error(\"Bad presence value: \" + opts.presence);\n    }\n    return this._http.authedRequest(\n        callback, \"PUT\", path, undefined, opts,\n    );\n};\n\nfunction _presenceList(callback, client, opts, method) {\n  const path = utils.encodeUri(\"/presence/list/$userId\", {\n      $userId: client.credentials.userId,\n  });\n  return client._http.authedRequest(callback, method, path, undefined, opts);\n}\n\n/**\n* Retrieve current user presence list.\n* @param {module:client.callback} callback Optional.\n* @return {module:client.Promise} Resolves: TODO\n* @return {module:http-api.MatrixError} Rejects: with an error response.\n*/\nMatrixClient.prototype.getPresenceList = function(callback) {\n  return _presenceList(callback, this, undefined, \"GET\");\n};\n\n/**\n* Add users to the current user presence list.\n* @param {module:client.callback} callback Optional.\n* @param {string[]} userIds\n* @return {module:client.Promise} Resolves: TODO\n* @return {module:http-api.MatrixError} Rejects: with an error response.\n*/\nMatrixClient.prototype.inviteToPresenceList = function(callback, userIds) {\n  const opts = {\"invite\": userIds};\n  return _presenceList(callback, this, opts, \"POST\");\n};\n\n/**\n* Drop users from the current user presence list.\n* @param {module:client.callback} callback Optional.\n* @param {string[]} userIds\n* @return {module:client.Promise} Resolves: TODO\n* @return {module:http-api.MatrixError} Rejects: with an error response.\n**/\nMatrixClient.prototype.dropFromPresenceList = function(callback, userIds) {\n  const opts = {\"drop\": userIds};\n  return _presenceList(callback, this, opts, \"POST\");\n};\n\n/**\n * Retrieve older messages from the given room and put them in the timeline.\n *\n * If this is called multiple times whilst a request is ongoing, the <i>same</i>\n * Promise will be returned. If there was a problem requesting scrollback, there\n * will be a small delay before another request can be made (to prevent tight-looping\n * when there is no connection).\n *\n * @param {Room} room The room to get older messages in.\n * @param {Integer} limit Optional. The maximum number of previous events to\n * pull in. Default: 30.\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: Room. If you are at the beginning\n * of the timeline, <code>Room.oldState.paginationToken</code> will be\n * <code>null</code>.\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.scrollback = function(room, limit, callback) {\n    if (utils.isFunction(limit)) {\n        callback = limit; limit = undefined;\n    }\n    limit = limit || 30;\n    let timeToWaitMs = 0;\n\n    let info = this._ongoingScrollbacks[room.roomId] || {};\n    if (info.promise) {\n        return info.promise;\n    } else if (info.errorTs) {\n        const timeWaitedMs = Date.now() - info.errorTs;\n        timeToWaitMs = Math.max(SCROLLBACK_DELAY_MS - timeWaitedMs, 0);\n    }\n\n    if (room.oldState.paginationToken === null) {\n        return q(room); // already at the start.\n    }\n    // attempt to grab more events from the store first\n    const numAdded = this.store.scrollback(room, limit).length;\n    if (numAdded === limit) {\n        // store contained everything we needed.\n        return q(room);\n    }\n    // reduce the required number of events appropriately\n    limit = limit - numAdded;\n\n    const path = utils.encodeUri(\n        \"/rooms/$roomId/messages\", {$roomId: room.roomId},\n    );\n    const params = {\n        from: room.oldState.paginationToken,\n        limit: limit,\n        dir: 'b',\n    };\n    const defer = q.defer();\n    info = {\n        promise: defer.promise,\n        errorTs: null,\n    };\n    const self = this;\n    // wait for a time before doing this request\n    // (which may be 0 in order not to special case the code paths)\n    q.delay(timeToWaitMs).then(function() {\n        return self._http.authedRequest(callback, \"GET\", path, params);\n    }).done(function(res) {\n        const matrixEvents = utils.map(res.chunk, _PojoToMatrixEventMapper(self));\n        room.addEventsToTimeline(matrixEvents, true, room.getLiveTimeline());\n        room.oldState.paginationToken = res.end;\n        if (res.chunk.length === 0) {\n            room.oldState.paginationToken = null;\n        }\n        self.store.storeEvents(room, matrixEvents, res.end, true);\n        self._ongoingScrollbacks[room.roomId] = null;\n        _resolve(callback, defer, room);\n    }, function(err) {\n        self._ongoingScrollbacks[room.roomId] = {\n            errorTs: Date.now(),\n        };\n        _reject(callback, defer, err);\n    });\n    this._ongoingScrollbacks[room.roomId] = info;\n    return defer.promise;\n};\n\n/**\n * Take an EventContext, and back/forward-fill results.\n *\n * @param {module:models/event-context.EventContext} eventContext  context\n *    object to be updated\n * @param {Object}  opts\n * @param {boolean} opts.backwards  true to fill backwards, false to go forwards\n * @param {boolean} opts.limit      number of events to request\n *\n * @return {module:client.Promise} Resolves: updated EventContext object\n * @return {Error} Rejects: with an error response.\n */\nMatrixClient.prototype.paginateEventContext = function(eventContext, opts) {\n    // TODO: we should implement a backoff (as per scrollback()) to deal more\n    // nicely with HTTP errors.\n    opts = opts || {};\n    const backwards = opts.backwards || false;\n\n    const token = eventContext.getPaginateToken(backwards);\n    if (!token) {\n        // no more results.\n        return q.reject(new Error(\"No paginate token\"));\n    }\n\n    const dir = backwards ? 'b' : 'f';\n    const pendingRequest = eventContext._paginateRequests[dir];\n\n    if (pendingRequest) {\n        // already a request in progress - return the existing promise\n        return pendingRequest;\n    }\n\n    const path = utils.encodeUri(\n        \"/rooms/$roomId/messages\", {$roomId: eventContext.getEvent().getRoomId()},\n    );\n    const params = {\n        from: token,\n        limit: ('limit' in opts) ? opts.limit : 30,\n        dir: dir,\n    };\n\n    const self = this;\n    const promise =\n        self._http.authedRequest(undefined, \"GET\", path, params,\n    ).then(function(res) {\n        let token = res.end;\n        if (res.chunk.length === 0) {\n            token = null;\n        } else {\n            const matrixEvents = utils.map(res.chunk, self.getEventMapper());\n            if (backwards) {\n                // eventContext expects the events in timeline order, but\n                // back-pagination returns them in reverse order.\n                matrixEvents.reverse();\n            }\n            eventContext.addEvents(matrixEvents, backwards);\n        }\n        eventContext.setPaginateToken(token, backwards);\n        return eventContext;\n    }).finally(function() {\n        eventContext._paginateRequests[dir] = null;\n    });\n    eventContext._paginateRequests[dir] = promise;\n\n    return promise;\n};\n\n/**\n * Get an EventTimeline for the given event\n *\n * <p>If the EventTimelineSet object already has the given event in its store, the\n * corresponding timeline will be returned. Otherwise, a /context request is\n * made, and used to construct an EventTimeline.\n *\n * @param {EventTimelineSet} timelineSet  The timelineSet to look for the event in\n * @param {string} eventId  The ID of the event to look for\n *\n * @return {module:client.Promise} Resolves:\n *    {@link module:models/event-timeline~EventTimeline} including the given\n *    event\n */\nMatrixClient.prototype.getEventTimeline = function(timelineSet, eventId) {\n    // don't allow any timeline support unless it's been enabled.\n    if (!this.timelineSupport) {\n        throw new Error(\"timeline support is disabled. Set the 'timelineSupport'\" +\n                    \" parameter to true when creating MatrixClient to enable\" +\n                    \" it.\");\n    }\n\n    if (timelineSet.getTimelineForEvent(eventId)) {\n        return q(timelineSet.getTimelineForEvent(eventId));\n    }\n\n    const path = utils.encodeUri(\n        \"/rooms/$roomId/context/$eventId\", {\n            $roomId: timelineSet.room.roomId,\n            $eventId: eventId,\n        },\n    );\n\n    // TODO: we should implement a backoff (as per scrollback()) to deal more\n    // nicely with HTTP errors.\n    const self = this;\n    const promise =\n        self._http.authedRequest(undefined, \"GET\", path,\n    ).then(function(res) {\n        if (!res.event) {\n            throw new Error(\"'event' not in '/context' result - homeserver too old?\");\n        }\n\n        // by the time the request completes, the event might have ended up in\n        // the timeline.\n        if (timelineSet.getTimelineForEvent(eventId)) {\n            return timelineSet.getTimelineForEvent(eventId);\n        }\n\n        // we start with the last event, since that's the point at which we\n        // have known state.\n        // events_after is already backwards; events_before is forwards.\n        res.events_after.reverse();\n        const events = res.events_after\n            .concat([res.event])\n            .concat(res.events_before);\n        const matrixEvents = utils.map(events, self.getEventMapper());\n\n        let timeline = timelineSet.getTimelineForEvent(matrixEvents[0].getId());\n        if (!timeline) {\n            timeline = timelineSet.addTimeline();\n            timeline.initialiseState(utils.map(res.state,\n                                               self.getEventMapper()));\n            timeline.getState(EventTimeline.FORWARDS).paginationToken = res.end;\n        }\n        timelineSet.addEventsToTimeline(matrixEvents, true, timeline, res.start);\n\n        // there is no guarantee that the event ended up in \"timeline\" (we\n        // might have switched to a neighbouring timeline) - so check the\n        // room's index again. On the other hand, there's no guarantee the\n        // event ended up anywhere, if it was later redacted, so we just\n        // return the timeline we first thought of.\n        const tl = timelineSet.getTimelineForEvent(eventId) || timeline;\n        return tl;\n    });\n    return promise;\n};\n\n\n/**\n * Take an EventTimeline, and back/forward-fill results.\n *\n * @param {module:models/event-timeline~EventTimeline} eventTimeline timeline\n *    object to be updated\n * @param {Object}   [opts]\n * @param {bool}     [opts.backwards = false]  true to fill backwards,\n *    false to go forwards\n * @param {number}   [opts.limit = 30]         number of events to request\n *\n * @return {module:client.Promise} Resolves to a boolean: false if there are no\n *    events and we reached either end of the timeline; else true.\n */\nMatrixClient.prototype.paginateEventTimeline = function(eventTimeline, opts) {\n    const isNotifTimeline = (eventTimeline.getTimelineSet() === this._notifTimelineSet);\n\n    // TODO: we should implement a backoff (as per scrollback()) to deal more\n    // nicely with HTTP errors.\n    opts = opts || {};\n    const backwards = opts.backwards || false;\n\n    if (isNotifTimeline) {\n        if (!backwards) {\n            throw new Error(\"paginateNotifTimeline can only paginate backwards\");\n        }\n    }\n\n    const dir = backwards ? EventTimeline.BACKWARDS : EventTimeline.FORWARDS;\n\n    const token = eventTimeline.getPaginationToken(dir);\n    if (!token) {\n        // no token - no results.\n        return q(false);\n    }\n\n    const pendingRequest = eventTimeline._paginationRequests[dir];\n\n    if (pendingRequest) {\n        // already a request in progress - return the existing promise\n        return pendingRequest;\n    }\n\n    let path, params, promise;\n    const self = this;\n\n    if (isNotifTimeline) {\n        path = \"/notifications\";\n        params = {\n            limit: ('limit' in opts) ? opts.limit : 30,\n            only: 'highlight',\n        };\n\n        if (token && token !== \"end\") {\n            params.from = token;\n        }\n\n        promise =\n            this._http.authedRequestWithPrefix(undefined, \"GET\", path, params,\n                undefined, httpApi.PREFIX_UNSTABLE,\n        ).then(function(res) {\n            const token = res.next_token;\n            const matrixEvents = [];\n\n            for (let i = 0; i < res.notifications.length; i++) {\n                const notification = res.notifications[i];\n                const event = self.getEventMapper()(notification.event);\n                event.setPushActions(\n                    PushProcessor.actionListToActionsObject(notification.actions),\n                );\n                event.event.room_id = notification.room_id; // XXX: gutwrenching\n                matrixEvents[i] = event;\n            }\n\n            eventTimeline.getTimelineSet()\n                .addEventsToTimeline(matrixEvents, backwards, eventTimeline, token);\n\n            // if we've hit the end of the timeline, we need to stop trying to\n            // paginate. We need to keep the 'forwards' token though, to make sure\n            // we can recover from gappy syncs.\n            if (backwards && !res.next_token) {\n                eventTimeline.setPaginationToken(null, dir);\n            }\n            return res.next_token ? true : false;\n        }).finally(function() {\n            eventTimeline._paginationRequests[dir] = null;\n        });\n        eventTimeline._paginationRequests[dir] = promise;\n    } else {\n        const room = this.getRoom(eventTimeline.getRoomId());\n        if (!room) {\n            throw new Error(\"Unknown room \" + eventTimeline.getRoomId());\n        }\n\n        path = utils.encodeUri(\n            \"/rooms/$roomId/messages\", {$roomId: eventTimeline.getRoomId()},\n        );\n        params = {\n            from: token,\n            limit: ('limit' in opts) ? opts.limit : 30,\n            dir: dir,\n        };\n\n        const filter = eventTimeline.getFilter();\n        if (filter) {\n            // XXX: it's horrific that /messages' filter parameter doesn't match\n            // /sync's one - see https://matrix.org/jira/browse/SPEC-451\n            params.filter = JSON.stringify(filter.getRoomTimelineFilterComponent());\n        }\n\n        promise =\n            this._http.authedRequest(undefined, \"GET\", path, params,\n        ).then(function(res) {\n            const token = res.end;\n            const matrixEvents = utils.map(res.chunk, self.getEventMapper());\n            eventTimeline.getTimelineSet()\n                .addEventsToTimeline(matrixEvents, backwards, eventTimeline, token);\n\n            // if we've hit the end of the timeline, we need to stop trying to\n            // paginate. We need to keep the 'forwards' token though, to make sure\n            // we can recover from gappy syncs.\n            if (backwards && res.end == res.start) {\n                eventTimeline.setPaginationToken(null, dir);\n            }\n            return res.end != res.start;\n        }).finally(function() {\n            eventTimeline._paginationRequests[dir] = null;\n        });\n        eventTimeline._paginationRequests[dir] = promise;\n    }\n\n    return promise;\n};\n\n/**\n * Reset the notifTimelineSet entirely, paginating in some historical notifs as\n * a starting point for subsequent pagination.\n */\nMatrixClient.prototype.resetNotifTimelineSet = function() {\n    if (!this._notifTimelineSet) {\n        return;\n    }\n\n    // FIXME: This thing is a total hack, and results in duplicate events being\n    // added to the timeline both from /sync and /notifications, and lots of\n    // slow and wasteful processing and pagination.  The correct solution is to\n    // extend /messages or /search or something to filter on notifications.\n\n    // use the fictitious token 'end'. in practice we would ideally give it\n    // the oldest backwards pagination token from /sync, but /sync doesn't\n    // know about /notifications, so we have no choice but to start paginating\n    // from the current point in time.  This may well overlap with historical\n    // notifs which are then inserted into the timeline by /sync responses.\n    this._notifTimelineSet.resetLiveTimeline('end', true);\n\n    // we could try to paginate a single event at this point in order to get\n    // a more valid pagination token, but it just ends up with an out of order\n    // timeline. given what a mess this is and given we're going to have duplicate\n    // events anyway, just leave it with the dummy token for now.\n    /*\n    this.paginateNotifTimeline(this._notifTimelineSet.getLiveTimeline(), {\n        backwards: true,\n        limit: 1\n    });\n    */\n};\n\n/**\n * Peek into a room and receive updates about the room. This only works if the\n * history visibility for the room is world_readable.\n * @param {String} roomId The room to attempt to peek into.\n * @return {module:client.Promise} Resolves: Room object\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.peekInRoom = function(roomId) {\n    if (this._peekSync) {\n        this._peekSync.stopPeeking();\n    }\n    this._peekSync = new SyncApi(this, this._clientOpts);\n    return this._peekSync.peek(roomId);\n};\n\n/**\n * Stop any ongoing room peeking.\n */\nMatrixClient.prototype.stopPeeking = function() {\n    if (this._peekSync) {\n        this._peekSync.stopPeeking();\n        this._peekSync = null;\n    }\n};\n\n/**\n * Set r/w flags for guest access in a room.\n * @param {string} roomId The room to configure guest access in.\n * @param {Object} opts Options\n * @param {boolean} opts.allowJoin True to allow guests to join this room. This\n * implicitly gives guests write access. If false or not given, guests are\n * explicitly forbidden from joining the room.\n * @param {boolean} opts.allowRead True to set history visibility to\n * be world_readable. This gives guests read access *from this point forward*.\n * If false or not given, history visibility is not modified.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.setGuestAccess = function(roomId, opts) {\n    const writePromise = this.sendStateEvent(roomId, \"m.room.guest_access\", {\n        guest_access: opts.allowJoin ? \"can_join\" : \"forbidden\",\n    });\n\n    let readPromise = q();\n    if (opts.allowRead) {\n        readPromise = this.sendStateEvent(roomId, \"m.room.history_visibility\", {\n            history_visibility: \"world_readable\",\n        });\n    }\n\n    return q.all(readPromise, writePromise);\n};\n\n// Registration/Login operations\n// =============================\n\n/**\n * Requests an email verification token for the purposes of registration.\n * This API proxies the Identity Server /validate/email/requestToken API,\n * adding registration-specific behaviour. Specifically, if an account with\n * the given email address already exists, it will either send an email\n * to the address informing them of this or return M_THREEPID_IN_USE\n * (which one is up to the Home Server).\n *\n * requestEmailToken calls the equivalent API directly on the ID server,\n * therefore bypassing the registration-specific logic.\n *\n * Parameters and return value are as for requestEmailToken\n\n * @param {string} email As requestEmailToken\n * @param {string} clientSecret As requestEmailToken\n * @param {number} sendAttempt As requestEmailToken\n * @param {string} nextLink As requestEmailToken\n * @param {module:client.callback} callback Optional. As requestEmailToken\n * @return {module:client.Promise} Resolves: As requestEmailToken\n */\nMatrixClient.prototype.requestRegisterEmailToken = function(email, clientSecret,\n                                                    sendAttempt, nextLink, callback) {\n    return this._requestTokenFromEndpoint(\n        \"/register/email/requestToken\",\n        email, clientSecret, sendAttempt, nextLink, callback,\n    );\n};\n\n/**\n * Requests an email verification token for the purposes of adding a\n * third party identifier to an account.\n * This API proxies the Identity Server /validate/email/requestToken API,\n * adding specific behaviour for the addition of email addresses to an\n * account. Specifically, if an account with\n * the given email address already exists, it will either send an email\n * to the address informing them of this or return M_THREEPID_IN_USE\n * (which one is up to the Home Server).\n *\n * requestEmailToken calls the equivalent API directly on the ID server,\n * therefore bypassing the email addition specific logic.\n *\n * @param {string} email As requestEmailToken\n * @param {string} clientSecret As requestEmailToken\n * @param {number} sendAttempt As requestEmailToken\n * @param {string} nextLink As requestEmailToken\n * @param {module:client.callback} callback Optional. As requestEmailToken\n * @return {module:client.Promise} Resolves: As requestEmailToken\n */\nMatrixClient.prototype.requestAdd3pidEmailToken = function(email, clientSecret,\n                                                    sendAttempt, nextLink, callback) {\n    return this._requestTokenFromEndpoint(\n        \"/account/3pid/email/requestToken\",\n        email, clientSecret, sendAttempt, nextLink, callback,\n    );\n};\n\n/**\n * Requests an email verification token for the purposes of resetting\n * the password on an account.\n * This API proxies the Identity Server /validate/email/requestToken API,\n * adding specific behaviour for the password resetting. Specifically,\n * if no account with the given email address exists, it may either\n * return M_THREEPID_NOT_FOUND or send an email\n * to the address informing them of this (which one is up to the Home Server).\n *\n * requestEmailToken calls the equivalent API directly on the ID server,\n * therefore bypassing the password reset specific logic.\n *\n * @param {string} email As requestEmailToken\n * @param {string} clientSecret As requestEmailToken\n * @param {number} sendAttempt As requestEmailToken\n * @param {string} nextLink As requestEmailToken\n * @param {module:client.callback} callback Optional. As requestEmailToken\n * @return {module:client.Promise} Resolves: As requestEmailToken\n */\nMatrixClient.prototype.requestPasswordEmailToken = function(email, clientSecret,\n                                                    sendAttempt, nextLink, callback) {\n    return this._requestTokenFromEndpoint(\n        \"/account/password/email/requestToken\",\n        email, clientSecret, sendAttempt, nextLink, callback,\n    );\n};\n\n/**\n * Internal utility function for requesting validation tokens from usage-specific\n * requestToken endpoints.\n *\n * @param {string} endpoint The endpoint to send the request to\n * @param {string} email As requestEmailToken\n * @param {string} clientSecret As requestEmailToken\n * @param {number} sendAttempt As requestEmailToken\n * @param {string} nextLink As requestEmailToken\n * @param {module:client.callback} callback Optional. As requestEmailToken\n * @return {module:client.Promise} Resolves: As requestEmailToken\n */\nMatrixClient.prototype._requestTokenFromEndpoint = function(endpoint,\n                                                    email, clientSecret,\n                                                    sendAttempt, nextLink, callback) {\n    const id_server_url = url.parse(this.idBaseUrl);\n    if (id_server_url.host === null) {\n        throw new Error(\"Invalid ID server URL: \" + this.idBaseUrl);\n    }\n\n    const params = {\n        client_secret: clientSecret,\n        email: email,\n        send_attempt: sendAttempt,\n        next_link: nextLink,\n        id_server: id_server_url.host,\n    };\n    return this._http.request(\n        callback, \"POST\", endpoint, undefined,\n        params,\n    );\n};\n\n\n// Push operations\n// ===============\n\n/**\n * Get the room-kind push rule associated with a room.\n * @param {string} scope \"global\" or device-specific.\n * @param {string} roomId the id of the room.\n * @return {object} the rule or undefined.\n */\nMatrixClient.prototype.getRoomPushRule = function(scope, roomId) {\n    // There can be only room-kind push rule per room\n    // and its id is the room id.\n    if (this.pushRules) {\n        for (let i = 0; i < this.pushRules[scope].room.length; i++) {\n            const rule = this.pushRules[scope].room[i];\n            if (rule.rule_id === roomId) {\n                return rule;\n            }\n        }\n    } else {\n        throw new Error(\n            \"SyncApi.sync() must be done before accessing to push rules.\",\n        );\n    }\n};\n\n/**\n * Set a room-kind muting push rule in a room.\n * The operation also updates MatrixClient.pushRules at the end.\n * @param {string} scope \"global\" or device-specific.\n * @param {string} roomId the id of the room.\n * @param {string} mute the mute state.\n * @return {module:client.Promise} Resolves: result object\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.setRoomMutePushRule = function(scope, roomId, mute) {\n    const self = this;\n    let deferred, hasDontNotifyRule;\n\n    // Get the existing room-kind push rule if any\n    const roomPushRule = this.getRoomPushRule(scope, roomId);\n    if (roomPushRule) {\n        if (0 <= roomPushRule.actions.indexOf(\"dont_notify\")) {\n            hasDontNotifyRule = true;\n        }\n    }\n\n    if (!mute) {\n        // Remove the rule only if it is a muting rule\n        if (hasDontNotifyRule) {\n            deferred = this.deletePushRule(scope, \"room\", roomPushRule.rule_id);\n        }\n    } else {\n        if (!roomPushRule) {\n            deferred = this.addPushRule(scope, \"room\", roomId, {\n                actions: [\"dont_notify\"],\n            });\n        } else if (!hasDontNotifyRule) {\n            // Remove the existing one before setting the mute push rule\n            // This is a workaround to SYN-590 (Push rule update fails)\n            deferred = q.defer();\n            this.deletePushRule(scope, \"room\", roomPushRule.rule_id)\n            .done(function() {\n                self.addPushRule(scope, \"room\", roomId, {\n                    actions: [\"dont_notify\"],\n                }).done(function() {\n                    deferred.resolve();\n                }, function(err) {\n                    deferred.reject(err);\n                });\n            }, function(err) {\n                deferred.reject(err);\n            });\n\n            deferred = deferred.promise;\n        }\n    }\n\n    if (deferred) {\n        // Update this.pushRules when the operation completes\n        const ruleRefreshDeferred = q.defer();\n        deferred.done(function() {\n            self.getPushRules().done(function(result) {\n                self.pushRules = result;\n                ruleRefreshDeferred.resolve();\n            }, function(err) {\n                ruleRefreshDeferred.reject(err);\n            });\n        }, function(err) {\n            // Update it even if the previous operation fails. This can help the\n            // app to recover when push settings has been modifed from another client\n            self.getPushRules().done(function(result) {\n                self.pushRules = result;\n                ruleRefreshDeferred.reject(err);\n            }, function(err2) {\n                ruleRefreshDeferred.reject(err);\n            });\n        });\n        return ruleRefreshDeferred.promise;\n    }\n};\n\n// Search\n// ======\n\n/**\n * Perform a server-side search for messages containing the given text.\n * @param {Object} opts Options for the search.\n * @param {string} opts.query The text to query.\n * @param {string=} opts.keys The keys to search on. Defaults to all keys. One\n * of \"content.body\", \"content.name\", \"content.topic\".\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.searchMessageText = function(opts, callback) {\n    return this.search({\n        body: {\n            search_categories: {\n                room_events: {\n                    keys: opts.keys,\n                    search_term: opts.query,\n                },\n            },\n        },\n    }, callback);\n};\n\n/**\n * Perform a server-side search for room events.\n *\n * The returned promise resolves to an object containing the fields:\n *\n *  * {number}  count:       estimate of the number of results\n *  * {string}  next_batch:  token for back-pagination; if undefined, there are\n *                           no more results\n *  * {Array}   highlights:  a list of words to highlight from the stemming\n *                           algorithm\n *  * {Array}   results:     a list of results\n *\n * Each entry in the results list is a {module:models/search-result.SearchResult}.\n *\n * @param {Object} opts\n * @param {string} opts.term     the term to search for\n * @param {Object} opts.filter   a JSON filter object to pass in the request\n * @return {module:client.Promise} Resolves: result object\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.searchRoomEvents = function(opts) {\n    // TODO: support groups\n\n    const body = {\n        search_categories: {\n            room_events: {\n                search_term: opts.term,\n                filter: opts.filter,\n                order_by: \"recent\",\n                event_context: {\n                    before_limit: 1,\n                    after_limit: 1,\n                    include_profile: true,\n                },\n            },\n        },\n    };\n\n    const searchResults = {\n        _query: body,\n        results: [],\n        highlights: [],\n    };\n\n    return this.search({body: body}).then(\n        this._processRoomEventsSearch.bind(this, searchResults),\n    );\n};\n\n/**\n * Take a result from an earlier searchRoomEvents call, and backfill results.\n *\n * @param  {object} searchResults  the results object to be updated\n * @return {module:client.Promise} Resolves: updated result object\n * @return {Error} Rejects: with an error response.\n */\nMatrixClient.prototype.backPaginateRoomEventsSearch = function(searchResults) {\n    // TODO: we should implement a backoff (as per scrollback()) to deal more\n    // nicely with HTTP errors.\n\n    if (!searchResults.next_batch) {\n        return q.reject(new Error(\"Cannot backpaginate event search any further\"));\n    }\n\n    if (searchResults.pendingRequest) {\n        // already a request in progress - return the existing promise\n        return searchResults.pendingRequest;\n    }\n\n    const searchOpts = {\n        body: searchResults._query,\n        next_batch: searchResults.next_batch,\n    };\n\n    const promise = this.search(searchOpts).then(\n        this._processRoomEventsSearch.bind(this, searchResults),\n    ).finally(function() {\n        searchResults.pendingRequest = null;\n    });\n    searchResults.pendingRequest = promise;\n\n    return promise;\n};\n\n/**\n * helper for searchRoomEvents and backPaginateRoomEventsSearch. Processes the\n * response from the API call and updates the searchResults\n *\n * @param {Object} searchResults\n * @param {Object} response\n * @return {Object} searchResults\n * @private\n */\nMatrixClient.prototype._processRoomEventsSearch = function(searchResults, response) {\n    const room_events = response.search_categories.room_events;\n\n    searchResults.count = room_events.count;\n    searchResults.next_batch = room_events.next_batch;\n\n    // combine the highlight list with our existing list; build an object\n    // to avoid O(N^2) fail\n    const highlights = {};\n    room_events.highlights.forEach(function(hl) {\n        highlights[hl] = 1;\n    });\n    searchResults.highlights.forEach(function(hl) {\n        highlights[hl] = 1;\n    });\n\n    // turn it back into a list.\n    searchResults.highlights = Object.keys(highlights);\n\n    // append the new results to our existing results\n    for (let i = 0; i < room_events.results.length; i++) {\n        const sr = SearchResult.fromJson(room_events.results[i], this.getEventMapper());\n        searchResults.results.push(sr);\n    }\n    return searchResults;\n};\n\n\n/**\n * Populate the store with rooms the user has left.\n * @return {module:client.Promise} Resolves: TODO - Resolved when the rooms have\n * been added to the data store.\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.syncLeftRooms = function() {\n    // Guard against multiple calls whilst ongoing and multiple calls post success\n    if (this._syncedLeftRooms) {\n        return q([]); // don't call syncRooms again if it succeeded.\n    }\n    if (this._syncLeftRoomsPromise) {\n        return this._syncLeftRoomsPromise; // return the ongoing request\n    }\n    const self = this;\n    const syncApi = new SyncApi(this, this._clientOpts);\n    this._syncLeftRoomsPromise = syncApi.syncLeftRooms();\n\n    // cleanup locks\n    this._syncLeftRoomsPromise.then(function(res) {\n        console.log(\"Marking success of sync left room request\");\n        self._syncedLeftRooms = true; // flip the bit on success\n    }).finally(function() {\n        self._syncLeftRoomsPromise = null; // cleanup ongoing request state\n    });\n\n    return this._syncLeftRoomsPromise;\n};\n\n// Filters\n// =======\n\n/**\n * Create a new filter.\n * @param {Object} content The HTTP body for the request\n * @return {Filter} Resolves to a Filter object.\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.createFilter = function(content) {\n    const self = this;\n    const path = utils.encodeUri(\"/user/$userId/filter\", {\n        $userId: this.credentials.userId,\n    });\n    return this._http.authedRequest(\n        undefined, \"POST\", path, undefined, content,\n    ).then(function(response) {\n        // persist the filter\n        const filter = Filter.fromJson(\n            self.credentials.userId, response.filter_id, content,\n        );\n        self.store.storeFilter(filter);\n        return filter;\n    });\n};\n\n/**\n * Retrieve a filter.\n * @param {string} userId The user ID of the filter owner\n * @param {string} filterId The filter ID to retrieve\n * @param {boolean} allowCached True to allow cached filters to be returned.\n * Default: True.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.getFilter = function(userId, filterId, allowCached) {\n    if (allowCached) {\n        const filter = this.store.getFilter(userId, filterId);\n        if (filter) {\n            return q(filter);\n        }\n    }\n\n    const self = this;\n    const path = utils.encodeUri(\"/user/$userId/filter/$filterId\", {\n        $userId: userId,\n        $filterId: filterId,\n    });\n\n    return this._http.authedRequest(\n        undefined, \"GET\", path, undefined, undefined,\n    ).then(function(response) {\n        // persist the filter\n        const filter = Filter.fromJson(\n            userId, filterId, response,\n        );\n        self.store.storeFilter(filter);\n        return filter;\n    });\n};\n\n/**\n * @param {string} filterName\n * @param {Filter} filter\n * @return {Promise<String>} Filter ID\n */\nMatrixClient.prototype.getOrCreateFilter = function(filterName, filter) {\n    const filterId = this.store.getFilterIdByName(filterName);\n    let promise = q();\n    const self = this;\n\n    if (filterId) {\n        // check that the existing filter matches our expectations\n        promise = self.getFilter(self.credentials.userId,\n                         filterId, true,\n        ).then(function(existingFilter) {\n            const oldDef = existingFilter.getDefinition();\n            const newDef = filter.getDefinition();\n\n            if (utils.deepCompare(oldDef, newDef)) {\n                // super, just use that.\n                // debuglog(\"Using existing filter ID %s: %s\", filterId,\n                //          JSON.stringify(oldDef));\n                return q(filterId);\n            }\n            // debuglog(\"Existing filter ID %s: %s; new filter: %s\",\n            //          filterId, JSON.stringify(oldDef), JSON.stringify(newDef));\n            self.store.setFilterIdByName(filterName, undefined);\n            return undefined;\n        }, function(error) {\n            // Synapse currently returns the following when the filter cannot be found:\n            // {\n            //     errcode: \"M_UNKNOWN\",\n            //     name: \"M_UNKNOWN\",\n            //     message: \"No row found\",\n            //     data: Object, httpStatus: 404\n            // }\n            if (error.httpStatus === 404 &&\n                (error.errcode === \"M_UNKNOWN\" || error.errcode === \"M_NOT_FOUND\")) {\n                // Clear existing filterId from localStorage\n                // if it no longer exists on the server\n                self.store.setFilterIdByName(filterName, undefined);\n                // Return a undefined value for existingId further down the promise chain\n                return undefined;\n            } else {\n                throw error;\n            }\n        });\n    }\n\n    return promise.then(function(existingId) {\n        if (existingId) {\n            return existingId;\n        }\n\n        // create a new filter\n        return self.createFilter(filter.getDefinition(),\n        ).then(function(createdFilter) {\n            // debuglog(\"Created new filter ID %s: %s\", createdFilter.filterId,\n            //          JSON.stringify(createdFilter.getDefinition()));\n            self.store.setFilterIdByName(filterName, createdFilter.filterId);\n            return createdFilter.filterId;\n        });\n    });\n};\n\n\n/**\n * Gets a bearer token from the Home Server that the user can\n * present to a third party in order to prove their ownership\n * of the Matrix account they are logged into.\n * @return {module:client.Promise} Resolves: Token object\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.getOpenIdToken = function() {\n    const path = utils.encodeUri(\"/user/$userId/openid/request_token\", {\n        $userId: this.credentials.userId,\n    });\n\n    return this._http.authedRequest(\n        undefined, \"POST\", path, undefined, {},\n    );\n};\n\n\n// VoIP operations\n// ===============\n\n/**\n * @param {module:client.callback} callback Optional.\n * @return {module:client.Promise} Resolves: TODO\n * @return {module:http-api.MatrixError} Rejects: with an error response.\n */\nMatrixClient.prototype.turnServer = function(callback) {\n    return this._http.authedRequest(callback, \"GET\", \"/voip/turnServer\");\n};\n\n/**\n * Get the TURN servers for this home server.\n * @return {Array<Object>} The servers or an empty list.\n */\nMatrixClient.prototype.getTurnServers = function() {\n    return this._turnServers || [];\n};\n\n// Higher level APIs\n// =================\n\n// TODO: stuff to handle:\n//   local echo\n//   event dup suppression? - apparently we should still be doing this\n//   tracking current display name / avatar per-message\n//   pagination\n//   re-sending (including persisting pending messages to be sent)\n//   - Need a nice way to callback the app for arbitrary events like\n//     displayname changes\n//   due to ambiguity (or should this be on a chat-specific layer)?\n//   reconnect after connectivity outages\n\n\n/**\n * High level helper method to call initialSync, emit the resulting events,\n * and then start polling the eventStream for new events. To listen for these\n * events, add a listener for {@link module:client~MatrixClient#event:\"event\"}\n * via {@link module:client~MatrixClient#on}.\n * @param {Object=} opts Options to apply when syncing.\n * @param {Number=} opts.initialSyncLimit The event <code>limit=</code> to apply\n * to initial sync. Default: 8.\n * @param {Boolean=} opts.includeArchivedRooms True to put <code>archived=true</code>\n * on the <code>/initialSync</code> request. Default: false.\n * @param {Boolean=} opts.resolveInvitesToProfiles True to do /profile requests\n * on every invite event if the displayname/avatar_url is not known for this user ID.\n * Default: false.\n *\n * @param {String=} opts.pendingEventOrdering Controls where pending messages\n * appear in a room's timeline. If \"<b>chronological</b>\", messages will appear\n * in the timeline when the call to <code>sendEvent</code> was made. If\n * \"<b>detached</b>\", pending messages will appear in a separate list,\n * accessbile via {@link module:models/room#getPendingEvents}. Default:\n * \"chronological\".\n *\n * @param {Number=} opts.pollTimeout The number of milliseconds to wait on /events.\n * Default: 30000 (30 seconds).\n *\n * @param {Filter=} opts.filter The filter to apply to /sync calls. This will override\n * the opts.initialSyncLimit, which would normally result in a timeline limit filter.\n */\nMatrixClient.prototype.startClient = function(opts) {\n    if (this.clientRunning) {\n        // client is already running.\n        return;\n    }\n    this.clientRunning = true;\n    // backwards compat for when 'opts' was 'historyLen'.\n    if (typeof opts === \"number\") {\n        opts = {\n            initialSyncLimit: opts,\n        };\n    }\n\n    if (this._crypto) {\n        this._crypto.uploadKeys(5).done();\n        const tenMinutes = 1000 * 60 * 10;\n        const self = this;\n        this._uploadIntervalID = global.setInterval(function() {\n            self._crypto.uploadKeys(5).done();\n        }, tenMinutes);\n    }\n\n    // periodically poll for turn servers if we support voip\n    checkTurnServers(this);\n\n    if (this._syncApi) {\n        // This shouldn't happen since we thought the client was not running\n        console.error(\"Still have sync object whilst not running: stopping old one\");\n        this._syncApi.stop();\n    }\n\n    // shallow-copy the opts dict before modifying and storing it\n    opts = Object.assign({}, opts);\n\n    opts.crypto = this._crypto;\n    this._clientOpts = opts;\n\n    this._syncApi = new SyncApi(this, opts);\n    this._syncApi.sync();\n};\n\n/**\n * High level helper method to stop the client from polling and allow a\n * clean shutdown.\n */\nMatrixClient.prototype.stopClient = function() {\n    this.clientRunning = false;\n    // TODO: f.e. Room => self.store.storeRoom(room) ?\n    if (this._syncApi) {\n        this._syncApi.stop();\n        this._syncApi = null;\n    }\n    if (this._crypto) {\n        global.clearInterval(this._uploadIntervalID);\n    }\n    global.clearTimeout(this._checkTurnServersTimeoutID);\n};\n\nfunction setupCallEventHandler(client) {\n    const candidatesByCall = {\n        // callId: [Candidate]\n    };\n\n    // Maintain a buffer of events before the client has synced for the first time.\n    // This buffer will be inspected to see if we should send incoming call\n    // notifications. It needs to be buffered to correctly determine if an\n    // incoming call has had a matching answer/hangup.\n    let callEventBuffer = [];\n    let isClientPrepared = false;\n    client.on(\"sync\", function(state) {\n        if (state === \"PREPARED\") {\n            isClientPrepared = true;\n            const ignoreCallIds = {}; // Set<String>\n            // inspect the buffer and mark all calls which have been answered\n            // or hung up before passing them to the call event handler.\n            for (let i = callEventBuffer.length - 1; i >= 0; i--) {\n                const ev = callEventBuffer[i];\n                if (ev.getType() === \"m.call.answer\" ||\n                        ev.getType() === \"m.call.hangup\") {\n                    ignoreCallIds[ev.getContent().call_id] = \"yep\";\n                }\n            }\n            // now loop through the buffer chronologically and inject them\n            callEventBuffer.forEach(function(e) {\n                if (ignoreCallIds[e.getContent().call_id]) {\n                    return;\n                }\n                callEventHandler(e);\n            });\n            callEventBuffer = [];\n        }\n    });\n\n    client.on(\"event\", function(event) {\n        if (!isClientPrepared) {\n            if (event.getType().indexOf(\"m.call.\") === 0) {\n                callEventBuffer.push(event);\n            }\n            return;\n        }\n        callEventHandler(event);\n    });\n\n    function callEventHandler(event) {\n        if (event.getType().indexOf(\"m.call.\") !== 0) {\n            return; // not a call event\n        }\n        const content = event.getContent();\n        let call = content.call_id ? client.callList[content.call_id] : undefined;\n        let i;\n        //console.log(\"RECV %s content=%s\", event.getType(), JSON.stringify(content));\n\n        if (event.getType() === \"m.call.invite\") {\n            if (event.getSender() === client.credentials.userId) {\n                return; // ignore invites you send\n            }\n\n            if (event.getAge() > content.lifetime) {\n                return; // expired call\n            }\n\n            if (call && call.state === \"ended\") {\n                return; // stale/old invite event\n            }\n            if (call) {\n                console.log(\n                    \"WARN: Already have a MatrixCall with id %s but got an \" +\n                    \"invite. Clobbering.\",\n                    content.call_id,\n                );\n            }\n\n            call = webRtcCall.createNewMatrixCall(client, event.getRoomId());\n            if (!call) {\n                console.log(\n                    \"Incoming call ID \" + content.call_id + \" but this client \" +\n                    \"doesn't support WebRTC\",\n                );\n                // don't hang up the call: there could be other clients\n                // connected that do support WebRTC and declining the\n                // the call on their behalf would be really annoying.\n                return;\n            }\n\n            call.callId = content.call_id;\n            call._initWithInvite(event);\n            client.callList[call.callId] = call;\n\n            // if we stashed candidate events for that call ID, play them back now\n            if (candidatesByCall[call.callId]) {\n                for (i = 0; i < candidatesByCall[call.callId].length; i++) {\n                    call._gotRemoteIceCandidate(\n                        candidatesByCall[call.callId][i],\n                    );\n                }\n            }\n\n            // Were we trying to call that user (room)?\n            let existingCall;\n            const existingCalls = utils.values(client.callList);\n            for (i = 0; i < existingCalls.length; ++i) {\n                const thisCall = existingCalls[i];\n                if (call.room_id === thisCall.room_id &&\n                        thisCall.direction === 'outbound' &&\n                        ([\"wait_local_media\", \"create_offer\", \"invite_sent\"].indexOf(\n                            thisCall.state) !== -1)) {\n                    existingCall = thisCall;\n                    break;\n                }\n            }\n\n            if (existingCall) {\n                // If we've only got to wait_local_media or create_offer and\n                // we've got an invite, pick the incoming call because we know\n                // we haven't sent our invite yet otherwise, pick whichever\n                // call has the lowest call ID (by string comparison)\n                if (existingCall.state === 'wait_local_media' ||\n                        existingCall.state === 'create_offer' ||\n                        existingCall.callId > call.callId) {\n                    console.log(\n                        \"Glare detected: answering incoming call \" + call.callId +\n                        \" and canceling outgoing call \" + existingCall.callId,\n                    );\n                    existingCall._replacedBy(call);\n                    call.answer();\n                } else {\n                    console.log(\n                        \"Glare detected: rejecting incoming call \" + call.callId +\n                        \" and keeping outgoing call \" + existingCall.callId,\n                    );\n                    call.hangup();\n                }\n            } else {\n                client.emit(\"Call.incoming\", call);\n            }\n        } else if (event.getType() === 'm.call.answer') {\n            if (!call) {\n                return;\n            }\n            if (event.getSender() === client.credentials.userId) {\n                if (call.state === 'ringing') {\n                    call._onAnsweredElsewhere(content);\n                }\n            } else {\n                call._receivedAnswer(content);\n            }\n        } else if (event.getType() === 'm.call.candidates') {\n            if (event.getSender() === client.credentials.userId) {\n                return;\n            }\n            if (!call) {\n                // store the candidates; we may get a call eventually.\n                if (!candidatesByCall[content.call_id]) {\n                    candidatesByCall[content.call_id] = [];\n                }\n                candidatesByCall[content.call_id] = candidatesByCall[\n                    content.call_id\n                ].concat(content.candidates);\n            } else {\n                for (i = 0; i < content.candidates.length; i++) {\n                    call._gotRemoteIceCandidate(content.candidates[i]);\n                }\n            }\n        } else if (event.getType() === 'm.call.hangup') {\n            // Note that we also observe our own hangups here so we can see\n            // if we've already rejected a call that would otherwise be valid\n            if (!call) {\n                // if not live, store the fact that the call has ended because\n                // we're probably getting events backwards so\n                // the hangup will come before the invite\n                call = webRtcCall.createNewMatrixCall(client, event.getRoomId());\n                if (call) {\n                    call.callId = content.call_id;\n                    call._initWithHangup(event);\n                    client.callList[content.call_id] = call;\n                }\n            } else {\n                if (call.state !== 'ended') {\n                    call._onHangupReceived(content);\n                    delete client.callList[content.call_id];\n                }\n            }\n        }\n    }\n}\n\nfunction checkTurnServers(client) {\n    if (!client._supportsVoip) {\n        return;\n    }\n    if (client.isGuest()) {\n        return; // guests can't access TURN servers\n    }\n\n    client.turnServer().done(function(res) {\n        if (res.uris) {\n            console.log(\"Got TURN URIs: \" + res.uris + \" refresh in \" +\n                res.ttl + \" secs\");\n            // map the response to a format that can be fed to\n            // RTCPeerConnection\n            const servers = {\n                urls: res.uris,\n                username: res.username,\n                credential: res.password,\n            };\n            client._turnServers = [servers];\n            // re-fetch when we're about to reach the TTL\n            client._checkTurnServersTimeoutID = setTimeout(() => {\n                checkTurnServers(client);\n            }, (res.ttl || (60 * 60)) * 1000 * 0.9);\n        }\n    }, function(err) {\n        console.error(\"Failed to get TURN URIs\");\n        client._checkTurnServersTimeoutID =\n            setTimeout(function() {\n checkTurnServers(client);\n}, 60000);\n    });\n}\n\nfunction _reject(callback, defer, err) {\n    if (callback) {\n        callback(err);\n    }\n    defer.reject(err);\n}\n\nfunction _resolve(callback, defer, res) {\n    if (callback) {\n        callback(null, res);\n    }\n    defer.resolve(res);\n}\n\nfunction _PojoToMatrixEventMapper(client) {\n    function mapper(plainOldJsObject) {\n        const event = new MatrixEvent(plainOldJsObject);\n        if (event.isEncrypted()) {\n            _decryptEvent(client, event);\n        }\n        return event;\n    }\n    return mapper;\n}\n\n/**\n * @return {Function}\n */\nMatrixClient.prototype.getEventMapper = function() {\n    return _PojoToMatrixEventMapper(this);\n};\n\n// Identity Server Operations\n// ==========================\n\n/**\n * Generates a random string suitable for use as a client secret. <strong>This\n * method is experimental and may change.</strong>\n * @return {string} A new client secret\n */\nMatrixClient.prototype.generateClientSecret = function() {\n    let ret = \"\";\n    const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\n    for (let i = 0; i < 32; i++) {\n        ret += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n\n    return ret;\n};\n\n/** */\nmodule.exports.MatrixClient = MatrixClient;\n/** */\nmodule.exports.CRYPTO_ENABLED = CRYPTO_ENABLED;\n\n// MatrixClient Event JSDocs\n\n/**\n * Fires whenever the SDK receives a new event.\n * <p>\n * This is only fired for live events received via /sync - it is not fired for\n * events received over context, search, or pagination APIs.\n *\n * @event module:client~MatrixClient#\"event\"\n * @param {MatrixEvent} event The matrix event which caused this event to fire.\n * @example\n * matrixClient.on(\"event\", function(event){\n *   var sender = event.getSender();\n * });\n */\n\n/**\n * Fires whenever the SDK receives a new to-device event.\n * @event module:client~MatrixClient#\"toDeviceEvent\"\n * @param {MatrixEvent} event The matrix event which caused this event to fire.\n * @example\n * matrixClient.on(\"toDeviceEvent\", function(event){\n *   var sender = event.getSender();\n * });\n */\n\n/**\n * Fires whenever the SDK's syncing state is updated. The state can be one of:\n * <ul>\n * <li>PREPARED : The client has synced with the server at least once and is\n * ready for methods to be called on it. This will be immediately followed by\n * a state of SYNCING. <i>This is the equivalent of \"syncComplete\" in the\n * previous API.</i></li>\n * <li>SYNCING : The client is currently polling for new events from the server.\n * This will be called <i>after</i> processing latest events from a sync.</li>\n * <li>ERROR : The client has had a problem syncing with the server. If this is\n * called <i>before</i> PREPARED then there was a problem performing the initial\n * sync. If this is called <i>after</i> PREPARED then there was a problem polling\n * the server for updates. This may be called multiple times even if the state is\n * already ERROR. <i>This is the equivalent of \"syncError\" in the previous\n * API.</i></li>\n * <li>RECONNECTING: The sync connedtion has dropped, but not in a way that should\n * be considered erroneous.\n * </li>\n * <li>STOPPED: The client has stopped syncing with server due to stopClient\n * being called.\n * </li>\n * </ul>\n * State transition diagram:\n * <pre>\n *                                          +---->STOPPED\n *                                          |\n *              +----->PREPARED -------> SYNCING <--+\n *              |        ^                  ^       |\n *              |        |                  |       |\n *              |        |                  V       |\n *   null ------+        |  +-RECONNECTING<-+       |\n *              |        |  V                       |\n *              +------->ERROR ---------------------+\n *\n * NB: 'null' will never be emitted by this event.\n * </pre>\n * Transitions:\n * <ul>\n * <li><code>null -> PREPARED</code> : Occurs when the initial sync is completed\n * first time. This involves setting up filters and obtaining push rules.\n * <li><code>null -> ERROR</code> : Occurs when the initial sync failed first time.\n * <li><code>ERROR -> PREPARED</code> : Occurs when the initial sync succeeds\n * after previously failing.\n * <li><code>PREPARED -> SYNCING</code> : Occurs immediately after transitioning\n * to PREPARED. Starts listening for live updates rather than catching up.\n * <li><code>SYNCING -> ERROR</code> : Occurs the first time a client cannot perform a\n * live update.\n * <li><code>ERROR -> SYNCING</code> : Occurs when the client has performed a\n * live update after having previously failed.\n * <li><code>ERROR -> ERROR</code> : Occurs when the client has failed to sync\n * for a second time or more.</li>\n * <li><code>SYNCING -> SYNCING</code> : Occurs when the client has performed a live\n * update. This is called <i>after</i> processing.</li>\n * <li><code>* -> STOPPED</code> : Occurs once the client has stopped syncing or\n * trying to sync after stopClient has been called.</li>\n * </ul>\n *\n * @event module:client~MatrixClient#\"sync\"\n *\n * @param {string} state An enum representing the syncing state. One of \"PREPARED\",\n * \"SYNCING\", \"ERROR\", \"STOPPED\".\n *\n * @param {?string} prevState An enum representing the previous syncing state.\n * One of \"PREPARED\", \"SYNCING\", \"ERROR\", \"STOPPED\" <b>or null</b>.\n *\n * @param {?Object} data Data about this transition.\n *\n * @param {MatrixError} data.err The matrix error if <code>state=ERROR</code>.\n *\n * @param {String} data.oldSyncToken The 'since' token passed to /sync.\n *    <code>null</code> for the first successful sync since this client was\n *    started. Only present if <code>state=PREPARED</code> or\n *    <code>state=SYNCING</code>.\n *\n * @param {String} data.nextSyncToken The 'next_batch' result from /sync, which\n *    will become the 'since' token for the next call to /sync. Only present if\n *    <code>state=PREPARED</code> or <code>state=SYNCING</code>.\n *\n * @example\n * matrixClient.on(\"sync\", function(state, prevState, data) {\n *   switch (state) {\n *     case \"ERROR\":\n *       // update UI to say \"Connection Lost\"\n *       break;\n *     case \"SYNCING\":\n *       // update UI to remove any \"Connection Lost\" message\n *       break;\n *     case \"PREPARED\":\n *       // the client instance is ready to be queried.\n *       var rooms = matrixClient.getRooms();\n *       break;\n *   }\n * });\n */\n\n /**\n * Fires whenever a new Room is added. This will fire when you are invited to a\n * room, as well as when you join a room. <strong>This event is experimental and\n * may change.</strong>\n * @event module:client~MatrixClient#\"Room\"\n * @param {Room} room The newly created, fully populated room.\n * @example\n * matrixClient.on(\"Room\", function(room){\n *   var roomId = room.roomId;\n * });\n */\n\n /**\n * Fires whenever a Room is removed. This will fire when you forget a room.\n * <strong>This event is experimental and may change.</strong>\n * @event module:client~MatrixClient#\"deleteRoom\"\n * @param {string} roomId The deleted room ID.\n * @example\n * matrixClient.on(\"deleteRoom\", function(roomId){\n *   // update UI from getRooms()\n * });\n */\n\n/**\n * Fires whenever an incoming call arrives.\n * @event module:client~MatrixClient#\"Call.incoming\"\n * @param {module:webrtc/call~MatrixCall} call The incoming call.\n * @example\n * matrixClient.on(\"Call.incoming\", function(call){\n *   call.answer(); // auto-answer\n * });\n */\n\n/**\n * Fires whenever the login session the JS SDK is using is no\n * longer valid and the user must log in again.\n * NB. This only fires when action is required from the user, not\n * when then login session can be renewed by using a refresh token.\n * @event module:client~MatrixClient#\"Session.logged_out\"\n * @example\n * matrixClient.on(\"Session.logged_out\", function(call){\n *   // show the login screen\n * });\n */\n\n/**\n * Fires when a device is marked as verified/unverified/blocked/unblocked by\n * {@link module:client~MatrixClient#setDeviceVerified|MatrixClient.setDeviceVerified} or\n * {@link module:client~MatrixClient#setDeviceBlocked|MatrixClient.setDeviceBlocked}.\n *\n * @event module:client~MatrixClient#\"deviceVerificationChanged\"\n * @param {string} userId the owner of the verified device\n * @param {string} deviceId the id of the verified device\n * @param {module:crypto/deviceinfo} deviceInfo updated device information\n */\n\n/**\n * Fires whenever new user-scoped account_data is added.\n * @event module:client~MatrixClient#\"Room\"\n * @param {MatrixEvent} event The event describing the account_data just added\n * @example\n * matrixClient.on(\"accountData\", function(event){\n *   myAccountData[event.type] = event.content;\n * });\n */\n\n\n// EventEmitter JSDocs\n\n/**\n * The {@link https://nodejs.org/api/events.html|EventEmitter} class.\n * @external EventEmitter\n * @see {@link https://nodejs.org/api/events.html}\n */\n\n/**\n * Adds a listener to the end of the listeners array for the specified event.\n * No checks are made to see if the listener has already been added. Multiple\n * calls passing the same combination of event and listener will result in the\n * listener being added multiple times.\n * @function external:EventEmitter#on\n * @param {string} event The event to listen for.\n * @param {Function} listener The function to invoke.\n * @return {EventEmitter} for call chaining.\n */\n\n/**\n * Alias for {@link external:EventEmitter#on}.\n * @function external:EventEmitter#addListener\n * @param {string} event The event to listen for.\n * @param {Function} listener The function to invoke.\n * @return {EventEmitter} for call chaining.\n */\n\n/**\n * Adds a <b>one time</b> listener for the event. This listener is invoked only\n * the next time the event is fired, after which it is removed.\n * @function external:EventEmitter#once\n * @param {string} event The event to listen for.\n * @param {Function} listener The function to invoke.\n * @return {EventEmitter} for call chaining.\n */\n\n/**\n * Remove a listener from the listener array for the specified event.\n * <b>Caution:</b> changes array indices in the listener array behind the\n * listener.\n * @function external:EventEmitter#removeListener\n * @param {string} event The event to listen for.\n * @param {Function} listener The function to invoke.\n * @return {EventEmitter} for call chaining.\n */\n\n/**\n * Removes all listeners, or those of the specified event. It's not a good idea\n * to remove listeners that were added elsewhere in the code, especially when\n * it's on an emitter that you didn't create (e.g. sockets or file streams).\n * @function external:EventEmitter#removeAllListeners\n * @param {string} event Optional. The event to remove listeners for.\n * @return {EventEmitter} for call chaining.\n */\n\n/**\n * Execute each of the listeners in order with the supplied arguments.\n * @function external:EventEmitter#emit\n * @param {string} event The event to emit.\n * @param {Function} listener The function to invoke.\n * @return {boolean} true if event had listeners, false otherwise.\n */\n\n/**\n * By default EventEmitters will print a warning if more than 10 listeners are\n * added for a particular event. This is a useful default which helps finding\n * memory leaks. Obviously not all Emitters should be limited to 10. This\n * function allows that to be increased. Set to zero for unlimited.\n * @function external:EventEmitter#setMaxListeners\n * @param {Number} n The max number of listeners.\n * @return {EventEmitter} for call chaining.\n */\n\n// MatrixClient Callback JSDocs\n\n/**\n * The standard MatrixClient callback interface. Functions which accept this\n * will specify 2 return arguments. These arguments map to the 2 parameters\n * specified in this callback.\n * @callback module:client.callback\n * @param {Object} err The error value, the \"rejected\" value or null.\n * @param {Object} data The data returned, the \"resolved\" value.\n */\n\n /**\n  * {@link https://github.com/kriskowal/q|A promise implementation (Q)}. Functions\n  * which return this will specify 2 return arguments. These arguments map to the\n  * \"onFulfilled\" and \"onRejected\" values of the Promise.\n  * @typedef {Object} Promise\n  * @static\n  * @property {Function} then promise.then(onFulfilled, onRejected, onProgress)\n  * @property {Function} catch promise.catch(onRejected)\n  * @property {Function} finally promise.finally(callback)\n  * @property {Function} done promise.done(onFulfilled, onRejected, onProgress)\n  */\n"]}