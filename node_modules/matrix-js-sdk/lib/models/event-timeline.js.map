{"version":3,"sources":["../../src/models/event-timeline.js"],"names":["RoomState","require","EventTimeline","eventTimelineSet","_eventTimelineSet","_roomId","room","roomId","_events","_baseIndex","_startState","paginationToken","_endState","_prevTimeline","_nextTimeline","_paginationRequests","_name","Date","toISOString","BACKWARDS","FORWARDS","prototype","initialiseState","stateEvents","length","Error","e","setStateEvents","getRoomId","getFilter","getTimelineSet","getBaseIndex","getEvents","getState","direction","getPaginationToken","setPaginationToken","token","getNeighbouringTimeline","setNeighbouringTimeline","neighbour","addEvent","event","atStart","stateContext","timelineSet","getUnfilteredTimelineSet","setEventMetadata","isState","sender","getType","insertIndex","splice","toStartOfTimeline","getSentinelMember","getSender","target","getStateKey","forwardLooking","removeEvent","eventId","i","ev","getId","toString","module","exports"],"mappings":"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","file":"event-timeline.js","sourcesContent":["/*\nCopyright 2016, 2017 OpenMarket Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\"use strict\";\n\n/**\n * @module models/event-timeline\n */\n\nconst RoomState = require(\"./room-state\");\n\n/**\n * Construct a new EventTimeline\n *\n * <p>An EventTimeline represents a contiguous sequence of events in a room.\n *\n * <p>As well as keeping track of the events themselves, it stores the state of\n * the room at the beginning and end of the timeline, and pagination tokens for\n * going backwards and forwards in the timeline.\n *\n * <p>In order that clients can meaningfully maintain an index into a timeline,\n * the EventTimeline object tracks a 'baseIndex'. This starts at zero, but is\n * incremented when events are prepended to the timeline. The index of an event\n * relative to baseIndex therefore remains constant.\n *\n * <p>Once a timeline joins up with its neighbour, they are linked together into a\n * doubly-linked list.\n *\n * @param {EventTimelineSet} eventTimelineSet the set of timelines this is part of\n * @constructor\n */\nfunction EventTimeline(eventTimelineSet) {\n    this._eventTimelineSet = eventTimelineSet;\n    this._roomId = eventTimelineSet.room ? eventTimelineSet.room.roomId : null;\n    this._events = [];\n    this._baseIndex = 0;\n    this._startState = new RoomState(this._roomId);\n    this._startState.paginationToken = null;\n    this._endState = new RoomState(this._roomId);\n    this._endState.paginationToken = null;\n\n    this._prevTimeline = null;\n    this._nextTimeline = null;\n\n    // this is used by client.js\n    this._paginationRequests = {'b': null, 'f': null};\n\n    this._name = this._roomId + \":\" + new Date().toISOString();\n}\n\n/**\n * Symbolic constant for methods which take a 'direction' argument:\n * refers to the start of the timeline, or backwards in time.\n */\nEventTimeline.BACKWARDS = \"b\";\n\n/**\n * Symbolic constant for methods which take a 'direction' argument:\n * refers to the end of the timeline, or forwards in time.\n */\nEventTimeline.FORWARDS = \"f\";\n\n/**\n * Initialise the start and end state with the given events\n *\n * <p>This can only be called before any events are added.\n *\n * @param {MatrixEvent[]} stateEvents list of state events to initialise the\n * state with.\n * @throws {Error} if an attempt is made to call this after addEvent is called.\n */\nEventTimeline.prototype.initialiseState = function(stateEvents) {\n    if (this._events.length > 0) {\n        throw new Error(\"Cannot initialise state after events are added\");\n    }\n\n    // We previously deep copied events here and used different copies in\n    // the oldState and state events: this decision seems to date back\n    // quite a way and was apparently made to fix a bug where modifications\n    // made to the start state leaked through to the end state.\n    // This really shouldn't be possible though: the events themselves should\n    // not change. Duplicating the events uses a lot of extra memory,\n    // so we now no longer do it. To assert that they really do never change,\n    // freeze them! Note that we can't do this for events in general:\n    // although it looks like the only things preventing us are the\n    // 'status' flag, forwardLooking (which is only set once when adding to the\n    // timeline) and possibly the sender (which seems like it should never be\n    // reset but in practice causes a lot of the tests to break).\n    for (const e of stateEvents) {\n        Object.freeze(e);\n    }\n\n    this._startState.setStateEvents(stateEvents);\n    this._endState.setStateEvents(stateEvents);\n};\n\n/**\n * Get the ID of the room for this timeline\n * @return {string} room ID\n */\nEventTimeline.prototype.getRoomId = function() {\n    return this._roomId;\n};\n\n/**\n * Get the filter for this timeline's timelineSet (if any)\n * @return {Filter} filter\n */\nEventTimeline.prototype.getFilter = function() {\n    return this._eventTimelineSet.getFilter();\n};\n\n/**\n * Get the timelineSet for this timeline\n * @return {EventTimelineSet} timelineSet\n */\nEventTimeline.prototype.getTimelineSet = function() {\n    return this._eventTimelineSet;\n};\n\n/**\n * Get the base index.\n *\n * <p>This is an index which is incremented when events are prepended to the\n * timeline. An individual event therefore stays at the same index in the array\n * relative to the base index (although note that a given event's index may\n * well be less than the base index, thus giving that event a negative relative\n * index).\n *\n * @return {number}\n */\nEventTimeline.prototype.getBaseIndex = function() {\n    return this._baseIndex;\n};\n\n/**\n * Get the list of events in this context\n *\n * @return {MatrixEvent[]} An array of MatrixEvents\n */\nEventTimeline.prototype.getEvents = function() {\n    return this._events;\n};\n\n/**\n * Get the room state at the start/end of the timeline\n *\n * @param {string} direction   EventTimeline.BACKWARDS to get the state at the\n *   start of the timeline; EventTimeline.FORWARDS to get the state at the end\n *   of the timeline.\n *\n * @return {RoomState} state at the start/end of the timeline\n */\nEventTimeline.prototype.getState = function(direction) {\n    if (direction == EventTimeline.BACKWARDS) {\n        return this._startState;\n    } else if (direction == EventTimeline.FORWARDS) {\n        return this._endState;\n    } else {\n        throw new Error(\"Invalid direction '\" + direction + \"'\");\n    }\n};\n\n/**\n * Get a pagination token\n *\n * @param {string} direction   EventTimeline.BACKWARDS to get the pagination\n *   token for going backwards in time; EventTimeline.FORWARDS to get the\n *   pagination token for going forwards in time.\n *\n * @return {?string} pagination token\n */\nEventTimeline.prototype.getPaginationToken = function(direction) {\n    return this.getState(direction).paginationToken;\n};\n\n/**\n * Set a pagination token\n *\n * @param {?string} token       pagination token\n *\n * @param {string} direction    EventTimeline.BACKWARDS to set the pagination\n *   token for going backwards in time; EventTimeline.FORWARDS to set the\n *   pagination token for going forwards in time.\n */\nEventTimeline.prototype.setPaginationToken = function(token, direction) {\n    this.getState(direction).paginationToken = token;\n};\n\n/**\n * Get the next timeline in the series\n *\n * @param {string} direction EventTimeline.BACKWARDS to get the previous\n *   timeline; EventTimeline.FORWARDS to get the next timeline.\n *\n * @return {?EventTimeline} previous or following timeline, if they have been\n * joined up.\n */\nEventTimeline.prototype.getNeighbouringTimeline = function(direction) {\n    if (direction == EventTimeline.BACKWARDS) {\n        return this._prevTimeline;\n    } else if (direction == EventTimeline.FORWARDS) {\n        return this._nextTimeline;\n    } else {\n        throw new Error(\"Invalid direction '\" + direction + \"'\");\n    }\n};\n\n/**\n * Set the next timeline in the series\n *\n * @param {EventTimeline} neighbour previous/following timeline\n *\n * @param {string} direction EventTimeline.BACKWARDS to set the previous\n *   timeline; EventTimeline.FORWARDS to set the next timeline.\n *\n * @throws {Error} if an attempt is made to set the neighbouring timeline when\n * it is already set.\n */\nEventTimeline.prototype.setNeighbouringTimeline = function(neighbour, direction) {\n    if (this.getNeighbouringTimeline(direction)) {\n        throw new Error(\"timeline already has a neighbouring timeline - \" +\n                        \"cannot reset neighbour\");\n    }\n\n    if (direction == EventTimeline.BACKWARDS) {\n        this._prevTimeline = neighbour;\n    } else if (direction == EventTimeline.FORWARDS) {\n        this._nextTimeline = neighbour;\n    } else {\n        throw new Error(\"Invalid direction '\" + direction + \"'\");\n    }\n\n    // make sure we don't try to paginate this timeline\n    this.setPaginationToken(null, direction);\n};\n\n/**\n * Add a new event to the timeline, and update the state\n *\n * @param {MatrixEvent} event   new event\n * @param {boolean}  atStart     true to insert new event at the start\n */\nEventTimeline.prototype.addEvent = function(event, atStart) {\n    const stateContext = atStart ? this._startState : this._endState;\n\n    // only call setEventMetadata on the unfiltered timelineSets\n    const timelineSet = this.getTimelineSet();\n    if (timelineSet.room &&\n        timelineSet.room.getUnfilteredTimelineSet() === timelineSet) {\n        EventTimeline.setEventMetadata(event, stateContext, atStart);\n\n        // modify state\n        if (event.isState()) {\n            stateContext.setStateEvents([event]);\n            // it is possible that the act of setting the state event means we\n            // can set more metadata (specifically sender/target props), so try\n            // it again if the prop wasn't previously set. It may also mean that\n            // the sender/target is updated (if the event set was a room member event)\n            // so we want to use the *updated* member (new avatar/name) instead.\n            //\n            // However, we do NOT want to do this on member events if we're going\n            // back in time, else we'll set the .sender value for BEFORE the given\n            // member event, whereas we want to set the .sender value for the ACTUAL\n            // member event itself.\n            if (!event.sender || (event.getType() === \"m.room.member\" && !atStart)) {\n                EventTimeline.setEventMetadata(event, stateContext, atStart);\n            }\n        }\n    }\n\n    let insertIndex;\n\n    if (atStart) {\n        insertIndex = 0;\n    } else {\n        insertIndex = this._events.length;\n    }\n\n    this._events.splice(insertIndex, 0, event); // insert element\n    if (atStart) {\n        this._baseIndex++;\n    }\n};\n\n/**\n * Static helper method to set sender and target properties\n *\n * @param {MatrixEvent} event   the event whose metadata is to be set\n * @param {RoomState} stateContext  the room state to be queried\n * @param {bool} toStartOfTimeline  if true the event's forwardLooking flag is set false\n */\nEventTimeline.setEventMetadata = function(event, stateContext, toStartOfTimeline) {\n    // set sender and target properties\n    event.sender = stateContext.getSentinelMember(\n        event.getSender(),\n    );\n    if (event.getType() === \"m.room.member\") {\n        event.target = stateContext.getSentinelMember(\n            event.getStateKey(),\n        );\n    }\n    if (event.isState()) {\n        // room state has no concept of 'old' or 'current', but we want the\n        // room state to regress back to previous values if toStartOfTimeline\n        // is set, which means inspecting prev_content if it exists. This\n        // is done by toggling the forwardLooking flag.\n        if (toStartOfTimeline) {\n            event.forwardLooking = false;\n        }\n    }\n};\n\n/**\n * Remove an event from the timeline\n *\n * @param {string} eventId  ID of event to be removed\n * @return {?MatrixEvent} removed event, or null if not found\n */\nEventTimeline.prototype.removeEvent = function(eventId) {\n    for (let i = this._events.length - 1; i >= 0; i--) {\n        const ev = this._events[i];\n        if (ev.getId() == eventId) {\n            this._events.splice(i, 1);\n            if (i < this._baseIndex) {\n                this._baseIndex--;\n            }\n            return ev;\n        }\n    }\n    return null;\n};\n\n/**\n * Return a string to identify this timeline, for debugging\n *\n * @return {string} name for this timeline\n */\nEventTimeline.prototype.toString = function() {\n    return this._name;\n};\n\n\n/**\n * The EventTimeline class\n */\nmodule.exports = EventTimeline;\n"]}