{"version":3,"sources":["../../src/models/event-timeline.js"],"names":["RoomState","require","utils","MatrixEvent","EventTimeline","eventTimelineSet","_eventTimelineSet","_roomId","room","roomId","_events","_baseIndex","_startState","paginationToken","_endState","_prevTimeline","_nextTimeline","_paginationRequests","_name","Date","toISOString","BACKWARDS","FORWARDS","prototype","initialiseState","stateEvents","length","Error","oldStateEvents","map","deepCopy","mxEvent","event","ev","setStateEvents","getRoomId","getFilter","getTimelineSet","getBaseIndex","getEvents","getState","direction","getPaginationToken","setPaginationToken","token","getNeighbouringTimeline","setNeighbouringTimeline","neighbour","addEvent","atStart","stateContext","timelineSet","getUnfilteredTimelineSet","setEventMetadata","isState","sender","getType","insertIndex","splice","toStartOfTimeline","getSentinelMember","getSender","target","getStateKey","forwardLooking","removeEvent","eventId","i","getId","toString","module","exports"],"mappings":"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","file":"event-timeline.js","sourcesContent":["\"use strict\";\n\n/**\n * @module models/event-timeline\n */\n\nconst RoomState = require(\"./room-state\");\nconst utils = require(\"../utils\");\nconst MatrixEvent = require(\"./event\").MatrixEvent;\n\n/**\n * Construct a new EventTimeline\n *\n * <p>An EventTimeline represents a contiguous sequence of events in a room.\n *\n * <p>As well as keeping track of the events themselves, it stores the state of\n * the room at the beginning and end of the timeline, and pagination tokens for\n * going backwards and forwards in the timeline.\n *\n * <p>In order that clients can meaningfully maintain an index into a timeline,\n * the EventTimeline object tracks a 'baseIndex'. This starts at zero, but is\n * incremented when events are prepended to the timeline. The index of an event\n * relative to baseIndex therefore remains constant.\n *\n * <p>Once a timeline joins up with its neighbour, they are linked together into a\n * doubly-linked list.\n *\n * @param {EventTimelineSet} eventTimelineSet the set of timelines this is part of\n * @constructor\n */\nfunction EventTimeline(eventTimelineSet) {\n    this._eventTimelineSet = eventTimelineSet;\n    this._roomId = eventTimelineSet.room ? eventTimelineSet.room.roomId : null;\n    this._events = [];\n    this._baseIndex = 0;\n    this._startState = new RoomState(this._roomId);\n    this._startState.paginationToken = null;\n    this._endState = new RoomState(this._roomId);\n    this._endState.paginationToken = null;\n\n    this._prevTimeline = null;\n    this._nextTimeline = null;\n\n    // this is used by client.js\n    this._paginationRequests = {'b': null, 'f': null};\n\n    this._name = this._roomId + \":\" + new Date().toISOString();\n}\n\n/**\n * Symbolic constant for methods which take a 'direction' argument:\n * refers to the start of the timeline, or backwards in time.\n */\nEventTimeline.BACKWARDS = \"b\";\n\n/**\n * Symbolic constant for methods which take a 'direction' argument:\n * refers to the end of the timeline, or forwards in time.\n */\nEventTimeline.FORWARDS = \"f\";\n\n/**\n * Initialise the start and end state with the given events\n *\n * <p>This can only be called before any events are added.\n *\n * @param {MatrixEvent[]} stateEvents list of state events to initialise the\n * state with.\n * @throws {Error} if an attempt is made to call this after addEvent is called.\n */\nEventTimeline.prototype.initialiseState = function(stateEvents) {\n    if (this._events.length > 0) {\n        throw new Error(\"Cannot initialise state after events are added\");\n    }\n\n    // we deep-copy the events here, in case they get changed later - we don't\n    // want changes to the start state leaking through to the end state.\n    const oldStateEvents = utils.map(\n        utils.deepCopy(\n            stateEvents.map(function(mxEvent) {\n                return mxEvent.event;\n            }),\n        ),\n    function(ev) {\n        return new MatrixEvent(ev);\n    });\n\n    this._startState.setStateEvents(oldStateEvents);\n    this._endState.setStateEvents(stateEvents);\n};\n\n/**\n * Get the ID of the room for this timeline\n * @return {string} room ID\n */\nEventTimeline.prototype.getRoomId = function() {\n    return this._roomId;\n};\n\n/**\n * Get the filter for this timeline's timelineSet (if any)\n * @return {Filter} filter\n */\nEventTimeline.prototype.getFilter = function() {\n    return this._eventTimelineSet.getFilter();\n};\n\n/**\n * Get the timelineSet for this timeline\n * @return {EventTimelineSet} timelineSet\n */\nEventTimeline.prototype.getTimelineSet = function() {\n    return this._eventTimelineSet;\n};\n\n/**\n * Get the base index.\n *\n * <p>This is an index which is incremented when events are prepended to the\n * timeline. An individual event therefore stays at the same index in the array\n * relative to the base index (although note that a given event's index may\n * well be less than the base index, thus giving that event a negative relative\n * index).\n *\n * @return {number}\n */\nEventTimeline.prototype.getBaseIndex = function() {\n    return this._baseIndex;\n};\n\n/**\n * Get the list of events in this context\n *\n * @return {MatrixEvent[]} An array of MatrixEvents\n */\nEventTimeline.prototype.getEvents = function() {\n    return this._events;\n};\n\n/**\n * Get the room state at the start/end of the timeline\n *\n * @param {string} direction   EventTimeline.BACKWARDS to get the state at the\n *   start of the timeline; EventTimeline.FORWARDS to get the state at the end\n *   of the timeline.\n *\n * @return {RoomState} state at the start/end of the timeline\n */\nEventTimeline.prototype.getState = function(direction) {\n    if (direction == EventTimeline.BACKWARDS) {\n        return this._startState;\n    } else if (direction == EventTimeline.FORWARDS) {\n        return this._endState;\n    } else {\n        throw new Error(\"Invalid direction '\" + direction + \"'\");\n    }\n};\n\n/**\n * Get a pagination token\n *\n * @param {string} direction   EventTimeline.BACKWARDS to get the pagination\n *   token for going backwards in time; EventTimeline.FORWARDS to get the\n *   pagination token for going forwards in time.\n *\n * @return {?string} pagination token\n */\nEventTimeline.prototype.getPaginationToken = function(direction) {\n    return this.getState(direction).paginationToken;\n};\n\n/**\n * Set a pagination token\n *\n * @param {?string} token       pagination token\n *\n * @param {string} direction    EventTimeline.BACKWARDS to set the pagination\n *   token for going backwards in time; EventTimeline.FORWARDS to set the\n *   pagination token for going forwards in time.\n */\nEventTimeline.prototype.setPaginationToken = function(token, direction) {\n    this.getState(direction).paginationToken = token;\n};\n\n/**\n * Get the next timeline in the series\n *\n * @param {string} direction EventTimeline.BACKWARDS to get the previous\n *   timeline; EventTimeline.FORWARDS to get the next timeline.\n *\n * @return {?EventTimeline} previous or following timeline, if they have been\n * joined up.\n */\nEventTimeline.prototype.getNeighbouringTimeline = function(direction) {\n    if (direction == EventTimeline.BACKWARDS) {\n        return this._prevTimeline;\n    } else if (direction == EventTimeline.FORWARDS) {\n        return this._nextTimeline;\n    } else {\n        throw new Error(\"Invalid direction '\" + direction + \"'\");\n    }\n};\n\n/**\n * Set the next timeline in the series\n *\n * @param {EventTimeline} neighbour previous/following timeline\n *\n * @param {string} direction EventTimeline.BACKWARDS to set the previous\n *   timeline; EventTimeline.FORWARDS to set the next timeline.\n *\n * @throws {Error} if an attempt is made to set the neighbouring timeline when\n * it is already set.\n */\nEventTimeline.prototype.setNeighbouringTimeline = function(neighbour, direction) {\n    if (this.getNeighbouringTimeline(direction)) {\n        throw new Error(\"timeline already has a neighbouring timeline - \" +\n                        \"cannot reset neighbour\");\n    }\n\n    if (direction == EventTimeline.BACKWARDS) {\n        this._prevTimeline = neighbour;\n    } else if (direction == EventTimeline.FORWARDS) {\n        this._nextTimeline = neighbour;\n    } else {\n        throw new Error(\"Invalid direction '\" + direction + \"'\");\n    }\n\n    // make sure we don't try to paginate this timeline\n    this.setPaginationToken(null, direction);\n};\n\n/**\n * Add a new event to the timeline, and update the state\n *\n * @param {MatrixEvent} event   new event\n * @param {boolean}  atStart     true to insert new event at the start\n */\nEventTimeline.prototype.addEvent = function(event, atStart) {\n    const stateContext = atStart ? this._startState : this._endState;\n\n    // only call setEventMetadata on the unfiltered timelineSets\n    const timelineSet = this.getTimelineSet();\n    if (timelineSet.room &&\n        timelineSet.room.getUnfilteredTimelineSet() === timelineSet) {\n        EventTimeline.setEventMetadata(event, stateContext, atStart);\n\n        // modify state\n        if (event.isState()) {\n            stateContext.setStateEvents([event]);\n            // it is possible that the act of setting the state event means we\n            // can set more metadata (specifically sender/target props), so try\n            // it again if the prop wasn't previously set. It may also mean that\n            // the sender/target is updated (if the event set was a room member event)\n            // so we want to use the *updated* member (new avatar/name) instead.\n            //\n            // However, we do NOT want to do this on member events if we're going\n            // back in time, else we'll set the .sender value for BEFORE the given\n            // member event, whereas we want to set the .sender value for the ACTUAL\n            // member event itself.\n            if (!event.sender || (event.getType() === \"m.room.member\" && !atStart)) {\n                EventTimeline.setEventMetadata(event, stateContext, atStart);\n            }\n        }\n    }\n\n    let insertIndex;\n\n    if (atStart) {\n        insertIndex = 0;\n    } else {\n        insertIndex = this._events.length;\n    }\n\n    this._events.splice(insertIndex, 0, event); // insert element\n    if (atStart) {\n        this._baseIndex++;\n    }\n};\n\n/**\n * Static helper method to set sender and target properties\n *\n * @param {MatrixEvent} event   the event whose metadata is to be set\n * @param {RoomState} stateContext  the room state to be queried\n * @param {bool} toStartOfTimeline  if true the event's forwardLooking flag is set false\n */\nEventTimeline.setEventMetadata = function(event, stateContext, toStartOfTimeline) {\n    // set sender and target properties\n    event.sender = stateContext.getSentinelMember(\n        event.getSender(),\n    );\n    if (event.getType() === \"m.room.member\") {\n        event.target = stateContext.getSentinelMember(\n            event.getStateKey(),\n        );\n    }\n    if (event.isState()) {\n        // room state has no concept of 'old' or 'current', but we want the\n        // room state to regress back to previous values if toStartOfTimeline\n        // is set, which means inspecting prev_content if it exists. This\n        // is done by toggling the forwardLooking flag.\n        if (toStartOfTimeline) {\n            event.forwardLooking = false;\n        }\n    }\n};\n\n/**\n * Remove an event from the timeline\n *\n * @param {string} eventId  ID of event to be removed\n * @return {?MatrixEvent} removed event, or null if not found\n */\nEventTimeline.prototype.removeEvent = function(eventId) {\n    for (let i = this._events.length - 1; i >= 0; i--) {\n        const ev = this._events[i];\n        if (ev.getId() == eventId) {\n            this._events.splice(i, 1);\n            if (i < this._baseIndex) {\n                this._baseIndex--;\n            }\n            return ev;\n        }\n    }\n    return null;\n};\n\n/**\n * Return a string to identify this timeline, for debugging\n *\n * @return {string} name for this timeline\n */\nEventTimeline.prototype.toString = function() {\n    return this._name;\n};\n\n\n/**\n * The EventTimeline class\n */\nmodule.exports = EventTimeline;\n"]}