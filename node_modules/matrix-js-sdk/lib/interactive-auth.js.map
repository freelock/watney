{"version":3,"sources":["../src/interactive-auth.js"],"names":["q","require","utils","InteractiveAuth","opts","_data","authData","_requestCallback","doRequest","_startAuthStageCallback","startAuthStage","_completionDeferred","prototype","attemptAuth","defer","_doRequest","_startNextAuthStage","promise","getSessionId","session","undefined","getStageParams","loginType","params","submitAuthDict","Error","auth","extend","self","prom","e","reject","then","result","console","log","resolve","error","httpStatus","data","flows","catch","done","nextStage","_chooseStage","stageError","errcode","flow","_chooseFlow","JSON","stringify","_firstUncompletedStage","completed","i","stages","length","stageType","indexOf","module","exports"],"mappings":"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","file":"interactive-auth.js","sourcesContent":["/*\nCopyright 2016 OpenMarket Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\"use strict\";\n\n/** @module interactive-auth */\nconst q = require(\"q\");\n\nconst utils = require(\"./utils\");\n\n/**\n * Abstracts the logic used to drive the interactive auth process.\n *\n * <p>Components implementing an interactive auth flow should instantiate one of\n * these, passing in the necessary callbacks to the constructor. They should\n * then call attemptAuth, which will return a promise which will resolve or\n * reject when the interactive-auth process completes.\n *\n * <p>Meanwhile, calls will be made to the startAuthStage and doRequest\n * callbacks, and information gathered from the user can be submitted with\n * submitAuthDict.\n *\n * @constructor\n * @alias module:interactive-auth\n *\n * @param {object} opts  options object\n *\n * @param {object?} opts.authData error response from the last request. If\n *    null, a request will be made with no auth before starting.\n *\n * @param {function(object?): module:client.Promise} opts.doRequest\n *     called with the new auth dict to submit the request. Should return a\n *     promise which resolves to the successful response or rejects with a\n *     MatrixError.\n *\n * @param {function(string, object?)} opts.startAuthStage\n *     called to ask the UI to start a particular auth stage. The arguments\n *     are: the login type (eg m.login.password); and (if the last request\n *     returned an error), an error object, with fields 'errcode' and 'error'.\n *\n */\nfunction InteractiveAuth(opts) {\n    this._data = opts.authData;\n    this._requestCallback = opts.doRequest;\n    this._startAuthStageCallback = opts.startAuthStage;\n    this._completionDeferred = null;\n}\n\nInteractiveAuth.prototype = {\n    /**\n     * begin the authentication process.\n     *\n     * @return {module:client.Promise}  which resolves to the response on success,\n     * or rejects with the error on failure.\n     */\n    attemptAuth: function() {\n        this._completionDeferred = q.defer();\n\n        if (!this._data) {\n            this._doRequest(null);\n        } else {\n            this._startNextAuthStage();\n        }\n\n        return this._completionDeferred.promise;\n    },\n\n    /**\n     * get the auth session ID\n     *\n     * @return {string} session id\n     */\n    getSessionId: function() {\n        return this._data ? this._data.session : undefined;\n    },\n\n    /**\n     * get the server params for a given stage\n     *\n     * @param {string} loginType login type for the stage\n     * @return {object?} any parameters from the server for this stage\n     */\n    getStageParams: function(loginType) {\n        let params = {};\n        if (this._data && this._data.params) {\n            params = this._data.params;\n        }\n        return params[loginType];\n    },\n\n    /**\n     * submit a new auth dict and fire off the request. This will either\n     * make attemptAuth resolve/reject, or cause the startAuthStage callback\n     * to be called for a new stage.\n     *\n     * @param {object} authData new auth dict to send to the server. Should\n     *    include a `type` propterty denoting the login type, as well as any\n     *    other params for that stage.\n     */\n    submitAuthDict: function(authData) {\n        if (!this._completionDeferred) {\n            throw new Error(\"submitAuthDict() called before attemptAuth()\");\n        }\n\n        // use the sessionid from the last request.\n        const auth = {\n            session: this._data.session,\n        };\n        utils.extend(auth, authData);\n\n        this._doRequest(auth);\n    },\n\n    /**\n     * Fire off a request, and either resolve the promise, or call\n     * startAuthStage.\n     *\n     * @private\n     * @param {object?} auth new auth dict, including session id\n     */\n    _doRequest: function(auth) {\n        const self = this;\n\n        // hackery to make sure that synchronous exceptions end up in the catch\n        // handler (without the additional event loop entailed by q.fcall or an\n        // extra q().then)\n        let prom;\n        try {\n            prom = this._requestCallback(auth);\n        } catch (e) {\n            prom = q.reject(e);\n        }\n\n        prom.then(\n            function(result) {\n                console.log(\"result from request: \", result);\n                self._completionDeferred.resolve(result);\n            }, function(error) {\n                if (error.httpStatus !== 401 || !error.data || !error.data.flows) {\n                    // doesn't look like an interactive-auth failure. fail the whole lot.\n                    throw error;\n                }\n                self._data = error.data;\n                self._startNextAuthStage();\n            },\n        ).catch(this._completionDeferred.reject).done();\n    },\n\n    /**\n     * Pick the next stage and call the callback\n     *\n     * @private\n     */\n    _startNextAuthStage: function() {\n        const nextStage = this._chooseStage();\n        if (!nextStage) {\n            throw new Error(\"No incomplete flows from the server\");\n        }\n\n        let stageError = null;\n        if (this._data.errcode || this._data.error) {\n            stageError = {\n                errcode: this._data.errcode || \"\",\n                error: this._data.error || \"\",\n            };\n        }\n        this._startAuthStageCallback(nextStage, stageError);\n    },\n\n    /**\n     * Pick the next auth stage\n     *\n     * @private\n     * @return {string?} login type\n     */\n    _chooseStage: function() {\n        const flow = this._chooseFlow();\n        console.log(\"Active flow => %s\", JSON.stringify(flow));\n        const nextStage = this._firstUncompletedStage(flow);\n        console.log(\"Next stage: %s\", nextStage);\n        return nextStage;\n    },\n\n    /**\n     * Pick one of the flows from the returned list\n     *\n     * @private\n     * @return {object} flow\n     */\n    _chooseFlow: function() {\n        const flows = this._data.flows || [];\n        // always use the first flow for now\n        return flows[0];\n    },\n\n    /**\n     * Get the first uncompleted stage in the given flow\n     *\n     * @private\n     * @param {object} flow\n     * @return {string} login type\n     */\n    _firstUncompletedStage: function(flow) {\n        const completed = (this._data || {}).completed || [];\n        for (let i = 0; i < flow.stages.length; ++i) {\n            const stageType = flow.stages[i];\n            if (completed.indexOf(stageType) === -1) {\n                return stageType;\n            }\n        }\n    },\n};\n\n\n/** */\nmodule.exports = InteractiveAuth;\n"]}