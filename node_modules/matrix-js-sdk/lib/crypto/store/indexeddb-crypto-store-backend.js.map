{"version":3,"sources":["../../../src/crypto/store/indexeddb-crypto-store-backend.js"],"names":["upgradeDatabase","VERSION","Backend","db","_db","onversionchange","ev","console","log","_dbName","close","request","requestBody","deferred","defer","txn","transaction","onerror","reject","_getOutgoingRoomKeyRequest","existing","room_id","session_id","resolve","store","objectStore","add","onsuccess","promise","callback","idx","index","cursorReq","openCursor","cursor","target","result","value","deepCompare","continue","wantedStates","length","stateIndex","wantedState","source","promiseifyTxn","then","requestId","expectedState","updates","data","state","warn","update","delete","oldVersion","createDatabase","outgoingRoomKeyRequestsStore","createObjectStore","keyPath","createIndex","oncomplete"],"mappings":";;;;;;;;;;;;;;;;;;;QAqQgBA,e,GAAAA,e;;AArQhB;;;;AACA;;;;;;AAEO,IAAMC,4BAAU,CAAhB;;AAEP;;;;;;;;IAOaC,O,WAAAA,O;AACT;;;AAGA,qBAAYC,EAAZ,EAAgB;AAAA;;AAAA;;AACZ,aAAKC,GAAL,GAAWD,EAAX;;AAEA;AACA;AACA;AACAA,WAAGE,eAAH,GAAqB,UAACC,EAAD,EAAQ;AACzBC,oBAAQC,GAAR,kCAA2C,MAAKC,OAAhD;AACAN,eAAGO,KAAH;AACH,SAHD;AAIH;;AAED;;;;;;;;;;;;;;uDAU+BC,O,EAAS;AACpC,gBAAMC,cAAcD,QAAQC,WAA5B;;AAEA,gBAAMC,WAAW,mBAAQC,KAAR,EAAjB;AACA,gBAAMC,MAAM,KAAKX,GAAL,CAASY,WAAT,CAAqB,yBAArB,EAAgD,WAAhD,CAAZ;AACAD,gBAAIE,OAAJ,GAAcJ,SAASK,MAAvB;;AAEA;AACA,iBAAKC,0BAAL,CAAgCJ,GAAhC,EAAqCH,WAArC,EAAkD,UAACQ,QAAD,EAAc;AAC5D,oBAAIA,QAAJ,EAAc;AACV;AACAb,4BAAQC,GAAR,CACI,+CACOI,YAAYS,OADnB,WACgCT,YAAYU,UAD5C,gCADJ;AAKAT,6BAASU,OAAT,CAAiBH,QAAjB;AACA;AACH;;AAED;AACA;AACAb,wBAAQC,GAAR,CACI,gCAA8BI,YAAYS,OAA1C,WACIT,YAAYU,UAFpB;AAIA,oBAAME,QAAQT,IAAIU,WAAJ,CAAgB,yBAAhB,CAAd;AACAD,sBAAME,GAAN,CAAUf,OAAV;AACAI,oBAAIY,SAAJ,GAAgB,YAAM;AAAEd,6BAASU,OAAT,CAAiBZ,OAAjB;AAA4B,iBAApD;AACH,aArBD;;AAuBA,mBAAOE,SAASe,OAAhB;AACH;;AAED;;;;;;;;;;;;;kDAU0BhB,W,EAAa;AACnC,gBAAMC,WAAW,mBAAQC,KAAR,EAAjB;;AAEA,gBAAMC,MAAM,KAAKX,GAAL,CAASY,WAAT,CAAqB,yBAArB,EAAgD,UAAhD,CAAZ;AACAD,gBAAIE,OAAJ,GAAcJ,SAASK,MAAvB;;AAEA,iBAAKC,0BAAL,CAAgCJ,GAAhC,EAAqCH,WAArC,EAAkD,UAACQ,QAAD,EAAc;AAC5DP,yBAASU,OAAT,CAAiBH,QAAjB;AACH,aAFD;AAGA,mBAAOP,SAASe,OAAhB;AACH;;AAED;;;;;;;;;;;;;;;mDAY2Bb,G,EAAKH,W,EAAaiB,Q,EAAU;AACnD,gBAAML,QAAQT,IAAIU,WAAJ,CAAgB,yBAAhB,CAAd;;AAEA,gBAAMK,MAAMN,MAAMO,KAAN,CAAY,SAAZ,CAAZ;AACA,gBAAMC,YAAYF,IAAIG,UAAJ,CAAe,CAC7BrB,YAAYS,OADiB,EAE7BT,YAAYU,UAFiB,CAAf,CAAlB;;AAKAU,sBAAUL,SAAV,GAAsB,UAACrB,EAAD,EAAQ;AAC1B,oBAAM4B,SAAS5B,GAAG6B,MAAH,CAAUC,MAAzB;AACA,oBAAG,CAACF,MAAJ,EAAY;AACR;AACAL,6BAAS,IAAT;AACA;AACH;;AAED,oBAAMT,WAAWc,OAAOG,KAAxB;;AAEA,oBAAI,gBAAMC,WAAN,CAAkBlB,SAASR,WAA3B,EAAwCA,WAAxC,CAAJ,EAA0D;AACtD;AACAiB,6BAAST,QAAT;AACA;AACH;;AAED;AACAc,uBAAOK,QAAP;AACH,aAlBD;AAmBH;;AAED;;;;;;;;;;;;;yDAUiCC,Y,EAAc;AAC3C,gBAAIA,aAAaC,MAAb,KAAwB,CAA5B,EAA+B;AAC3B,uBAAO,mBAAQlB,OAAR,CAAgB,IAAhB,CAAP;AACH;;AAED;AACA;AACA;;AAEA;AACA,gBAAImB,aAAa,CAAjB;AACA,gBAAIN,eAAJ;;AAEA,qBAAST,SAAT,CAAmBrB,EAAnB,EAAuB;AACnB,oBAAM4B,SAAS5B,GAAG6B,MAAH,CAAUC,MAAzB;AACA,oBAAIF,MAAJ,EAAY;AACR;AACAE,6BAASF,OAAOG,KAAhB;AACA;AACH;;AAED;AACAK;AACA,oBAAIA,cAAcF,aAAaC,MAA/B,EAAuC;AACnC;AACA;AACH;;AAED,oBAAME,cAAcH,aAAaE,UAAb,CAApB;AACA,oBAAMV,YAAY1B,GAAG6B,MAAH,CAAUS,MAAV,CAAiBX,UAAjB,CAA4BU,WAA5B,CAAlB;AACAX,0BAAUL,SAAV,GAAsBA,SAAtB;AACH;;AAED,gBAAMZ,MAAM,KAAKX,GAAL,CAASY,WAAT,CAAqB,yBAArB,EAAgD,UAAhD,CAAZ;AACA,gBAAMQ,QAAQT,IAAIU,WAAJ,CAAgB,yBAAhB,CAAd;;AAEA,gBAAMkB,cAAcH,aAAaE,UAAb,CAApB;AACA,gBAAMV,YAAYR,MAAMO,KAAN,CAAY,OAAZ,EAAqBE,UAArB,CAAgCU,WAAhC,CAAlB;AACAX,sBAAUL,SAAV,GAAsBA,SAAtB;;AAEA,mBAAOkB,cAAc9B,GAAd,EAAmB+B,IAAnB,CAAwB;AAAA,uBAAMV,MAAN;AAAA,aAAxB,CAAP;AACH;;AAED;;;;;;;;;;;;;;;qDAY6BW,S,EAAWC,a,EAAeC,O,EAAS;AAC5D,gBAAIb,SAAS,IAAb;;AAEA,qBAAST,SAAT,CAAmBrB,EAAnB,EAAuB;AACnB,oBAAM4B,SAAS5B,GAAG6B,MAAH,CAAUC,MAAzB;AACA,oBAAI,CAACF,MAAL,EAAa;AACT;AACH;AACD,oBAAMgB,OAAOhB,OAAOG,KAApB;AACA,oBAAIa,KAAKC,KAAL,IAAcH,aAAlB,EAAiC;AAC7BzC,4BAAQ6C,IAAR,CACI,yCAAuCJ,aAAvC,4CACgCE,KAAKC,KADrC,CADJ;AAIA;AACH;AACD,sCAAcD,IAAd,EAAoBD,OAApB;AACAf,uBAAOmB,MAAP,CAAcH,IAAd;AACAd,yBAASc,IAAT;AACH;;AAED,gBAAMnC,MAAM,KAAKX,GAAL,CAASY,WAAT,CAAqB,yBAArB,EAAgD,WAAhD,CAAZ;AACA,gBAAMgB,YAAYjB,IAAIU,WAAJ,CAAgB,yBAAhB,EACPQ,UADO,CACIc,SADJ,CAAlB;AAEAf,sBAAUL,SAAV,GAAsBA,SAAtB;AACA,mBAAOkB,cAAc9B,GAAd,EAAmB+B,IAAnB,CAAwB;AAAA,uBAAMV,MAAN;AAAA,aAAxB,CAAP;AACH;;AAED;;;;;;;;;;;;qDAS6BW,S,EAAWC,a,EAAe;AACnD,gBAAMjC,MAAM,KAAKX,GAAL,CAASY,WAAT,CAAqB,yBAArB,EAAgD,WAAhD,CAAZ;AACA,gBAAMgB,YAAYjB,IAAIU,WAAJ,CAAgB,yBAAhB,EACPQ,UADO,CACIc,SADJ,CAAlB;AAEAf,sBAAUL,SAAV,GAAsB,UAACrB,EAAD,EAAQ;AAC1B,oBAAM4B,SAAS5B,GAAG6B,MAAH,CAAUC,MAAzB;AACA,oBAAI,CAACF,MAAL,EAAa;AACT;AACH;AACD,oBAAMgB,OAAOhB,OAAOG,KAApB;AACA,oBAAIa,KAAKC,KAAL,IAAcH,aAAlB,EAAiC;AAC7BzC,4BAAQ6C,IAAR,CACI,6CAA2CF,KAAKC,KAAhD,yBACmBH,aADnB,OADJ;AAIA;AACH;AACDd,uBAAOoB,MAAP;AACH,aAdD;AAeA,mBAAOT,cAAc9B,GAAd,CAAP;AACH;;;;;AAGE,SAASf,eAAT,CAAyBG,EAAzB,EAA6BoD,UAA7B,EAAyC;AAC5ChD,YAAQC,GAAR,CACI,iDAA+C+C,UAA/C,aACatD,OADb,CADJ;AAIA,QAAIsD,aAAa,CAAjB,EAAoB;AAAE;AAClBC,uBAAerD,EAAf;AACH;AACD;AACH;;AAED,SAASqD,cAAT,CAAwBrD,EAAxB,EAA4B;AACxB,QAAMsD,+BACFtD,GAAGuD,iBAAH,CAAqB,yBAArB,EAAgD,EAAEC,SAAS,WAAX,EAAhD,CADJ;;AAGA;AACA;AACAF,iCAA6BG,WAA7B,CAAyC,SAAzC,EACI,CAAC,qBAAD,EAAwB,wBAAxB,CADJ;;AAIAH,iCAA6BG,WAA7B,CAAyC,OAAzC,EAAkD,OAAlD;AACH;;AAED,SAASf,aAAT,CAAuB9B,GAAvB,EAA4B;AACxB,WAAO,uBAAY,UAACQ,OAAD,EAAUL,MAAV,EAAqB;AACpCH,YAAI8C,UAAJ,GAAiBtC,OAAjB;AACAR,YAAIE,OAAJ,GAAcC,MAAd;AACH,KAHM,CAAP;AAIH","file":"indexeddb-crypto-store-backend.js","sourcesContent":["import Promise from 'bluebird';\nimport utils from '../../utils';\n\nexport const VERSION = 1;\n\n/**\n * Implementation of a CryptoStore which is backed by an existing\n * IndexedDB connection. Generally you want IndexedDBCryptoStore\n * which connects to the database and defers to one of these.\n *\n * @implements {module:crypto/store/base~CryptoStore}\n */\nexport class Backend {\n    /**\n     * @param {IDBDatabase} db\n     */\n    constructor(db) {\n        this._db = db;\n\n        // make sure we close the db on `onversionchange` - otherwise\n        // attempts to delete the database will block (and subsequent\n        // attempts to re-create it will also block).\n        db.onversionchange = (ev) => {\n            console.log(`versionchange for indexeddb ${this._dbName}: closing`);\n            db.close();\n        };\n    }\n\n    /**\n     * Look for an existing outgoing room key request, and if none is found,\n     * add a new one\n     *\n     * @param {module:crypto/store/base~OutgoingRoomKeyRequest} request\n     *\n     * @returns {Promise} resolves to\n     *    {@link module:crypto/store/base~OutgoingRoomKeyRequest}: either the\n     *    same instance as passed in, or the existing one.\n     */\n    getOrAddOutgoingRoomKeyRequest(request) {\n        const requestBody = request.requestBody;\n\n        const deferred = Promise.defer();\n        const txn = this._db.transaction(\"outgoingRoomKeyRequests\", \"readwrite\");\n        txn.onerror = deferred.reject;\n\n        // first see if we already have an entry for this request.\n        this._getOutgoingRoomKeyRequest(txn, requestBody, (existing) => {\n            if (existing) {\n                // this entry matches the request - return it.\n                console.log(\n                    `already have key request outstanding for ` +\n                        `${requestBody.room_id} / ${requestBody.session_id}: ` +\n                        `not sending another`,\n                );\n                deferred.resolve(existing);\n                return;\n            }\n\n            // we got to the end of the list without finding a match\n            // - add the new request.\n            console.log(\n                `enqueueing key request for ${requestBody.room_id} / ` +\n                    requestBody.session_id,\n            );\n            const store = txn.objectStore(\"outgoingRoomKeyRequests\");\n            store.add(request);\n            txn.onsuccess = () => { deferred.resolve(request); };\n        });\n\n        return deferred.promise;\n    }\n\n    /**\n     * Look for an existing room key request\n     *\n     * @param {module:crypto~RoomKeyRequestBody} requestBody\n     *    existing request to look for\n     *\n     * @return {Promise} resolves to the matching\n     *    {@link module:crypto/store/base~OutgoingRoomKeyRequest}, or null if\n     *    not found\n     */\n    getOutgoingRoomKeyRequest(requestBody) {\n        const deferred = Promise.defer();\n\n        const txn = this._db.transaction(\"outgoingRoomKeyRequests\", \"readonly\");\n        txn.onerror = deferred.reject;\n\n        this._getOutgoingRoomKeyRequest(txn, requestBody, (existing) => {\n            deferred.resolve(existing);\n        });\n        return deferred.promise;\n    }\n\n    /**\n     * look for an existing room key request in the db\n     *\n     * @private\n     * @param {IDBTransaction} txn  database transaction\n     * @param {module:crypto~RoomKeyRequestBody} requestBody\n     *    existing request to look for\n     * @param {Function} callback  function to call with the results of the\n     *    search. Either passed a matching\n     *    {@link module:crypto/store/base~OutgoingRoomKeyRequest}, or null if\n     *    not found.\n     */\n    _getOutgoingRoomKeyRequest(txn, requestBody, callback) {\n        const store = txn.objectStore(\"outgoingRoomKeyRequests\");\n\n        const idx = store.index(\"session\");\n        const cursorReq = idx.openCursor([\n            requestBody.room_id,\n            requestBody.session_id,\n        ]);\n\n        cursorReq.onsuccess = (ev) => {\n            const cursor = ev.target.result;\n            if(!cursor) {\n                // no match found\n                callback(null);\n                return;\n            }\n\n            const existing = cursor.value;\n\n            if (utils.deepCompare(existing.requestBody, requestBody)) {\n                // got a match\n                callback(existing);\n                return;\n            }\n\n            // look at the next entry in the index\n            cursor.continue();\n        };\n    }\n\n    /**\n     * Look for room key requests by state\n     *\n     * @param {Array<Number>} wantedStates list of acceptable states\n     *\n     * @return {Promise} resolves to the a\n     *    {@link module:crypto/store/base~OutgoingRoomKeyRequest}, or null if\n     *    there are no pending requests in those states. If there are multiple\n     *    requests in those states, an arbitrary one is chosen.\n     */\n    getOutgoingRoomKeyRequestByState(wantedStates) {\n        if (wantedStates.length === 0) {\n            return Promise.resolve(null);\n        }\n\n        // this is a bit tortuous because we need to make sure we do the lookup\n        // in a single transaction, to avoid having a race with the insertion\n        // code.\n\n        // index into the wantedStates array\n        let stateIndex = 0;\n        let result;\n\n        function onsuccess(ev) {\n            const cursor = ev.target.result;\n            if (cursor) {\n                // got a match\n                result = cursor.value;\n                return;\n            }\n\n            // try the next state in the list\n            stateIndex++;\n            if (stateIndex >= wantedStates.length) {\n                // no matches\n                return;\n            }\n\n            const wantedState = wantedStates[stateIndex];\n            const cursorReq = ev.target.source.openCursor(wantedState);\n            cursorReq.onsuccess = onsuccess;\n        }\n\n        const txn = this._db.transaction(\"outgoingRoomKeyRequests\", \"readonly\");\n        const store = txn.objectStore(\"outgoingRoomKeyRequests\");\n\n        const wantedState = wantedStates[stateIndex];\n        const cursorReq = store.index(\"state\").openCursor(wantedState);\n        cursorReq.onsuccess = onsuccess;\n\n        return promiseifyTxn(txn).then(() => result);\n    }\n\n    /**\n     * Look for an existing room key request by id and state, and update it if\n     * found\n     *\n     * @param {string} requestId      ID of request to update\n     * @param {number} expectedState  state we expect to find the request in\n     * @param {Object} updates        name/value map of updates to apply\n     *\n     * @returns {Promise} resolves to\n     *    {@link module:crypto/store/base~OutgoingRoomKeyRequest}\n     *    updated request, or null if no matching row was found\n     */\n    updateOutgoingRoomKeyRequest(requestId, expectedState, updates) {\n        let result = null;\n\n        function onsuccess(ev) {\n            const cursor = ev.target.result;\n            if (!cursor) {\n                return;\n            }\n            const data = cursor.value;\n            if (data.state != expectedState) {\n                console.warn(\n                    `Cannot update room key request from ${expectedState} ` +\n                    `as it was already updated to ${data.state}`,\n                );\n                return;\n            }\n            Object.assign(data, updates);\n            cursor.update(data);\n            result = data;\n        }\n\n        const txn = this._db.transaction(\"outgoingRoomKeyRequests\", \"readwrite\");\n        const cursorReq = txn.objectStore(\"outgoingRoomKeyRequests\")\n                  .openCursor(requestId);\n        cursorReq.onsuccess = onsuccess;\n        return promiseifyTxn(txn).then(() => result);\n    }\n\n    /**\n     * Look for an existing room key request by id and state, and delete it if\n     * found\n     *\n     * @param {string} requestId      ID of request to update\n     * @param {number} expectedState  state we expect to find the request in\n     *\n     * @returns {Promise} resolves once the operation is completed\n     */\n    deleteOutgoingRoomKeyRequest(requestId, expectedState) {\n        const txn = this._db.transaction(\"outgoingRoomKeyRequests\", \"readwrite\");\n        const cursorReq = txn.objectStore(\"outgoingRoomKeyRequests\")\n                  .openCursor(requestId);\n        cursorReq.onsuccess = (ev) => {\n            const cursor = ev.target.result;\n            if (!cursor) {\n                return;\n            }\n            const data = cursor.value;\n            if (data.state != expectedState) {\n                console.warn(\n                    `Cannot delete room key request in state ${data.state} `\n                        + `(expected ${expectedState})`,\n                );\n                return;\n            }\n            cursor.delete();\n        };\n        return promiseifyTxn(txn);\n    }\n}\n\nexport function upgradeDatabase(db, oldVersion) {\n    console.log(\n        `Upgrading IndexedDBCryptoStore from version ${oldVersion}`\n            + ` to ${VERSION}`,\n    );\n    if (oldVersion < 1) { // The database did not previously exist.\n        createDatabase(db);\n    }\n    // Expand as needed.\n}\n\nfunction createDatabase(db) {\n    const outgoingRoomKeyRequestsStore =\n        db.createObjectStore(\"outgoingRoomKeyRequests\", { keyPath: \"requestId\" });\n\n    // we assume that the RoomKeyRequestBody will have room_id and session_id\n    // properties, to make the index efficient.\n    outgoingRoomKeyRequestsStore.createIndex(\"session\",\n        [\"requestBody.room_id\", \"requestBody.session_id\"],\n    );\n\n    outgoingRoomKeyRequestsStore.createIndex(\"state\", \"state\");\n}\n\nfunction promiseifyTxn(txn) {\n    return new Promise((resolve, reject) => {\n        txn.oncomplete = resolve;\n        txn.onerror = reject;\n    });\n}\n"]}