/*
Copyright 2017 Vector Creations Ltd

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
"use strict";

/**
 * @module crypto/DeviceList
 *
 * Manages the list of other users' devices
 */

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _q = require('q');

var _q2 = _interopRequireDefault(_q);

var _deviceinfo = require('./deviceinfo');

var _deviceinfo2 = _interopRequireDefault(_deviceinfo);

var _olmlib = require('./olmlib');

var _olmlib2 = _interopRequireDefault(_olmlib);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @alias module:crypto/DeviceList
 */
var DeviceList = function () {
    function DeviceList(baseApis, sessionStore, olmDevice) {
        _classCallCheck(this, DeviceList);

        this._baseApis = baseApis;
        this._sessionStore = sessionStore;
        this._olmDevice = olmDevice;

        // users with outdated device lists
        // userId -> true
        this._pendingUsersWithNewDevices = {};

        // userId -> true
        this._keyDownloadsInProgressByUser = {};

        // deferred which is resolved when the current device query resolves.
        // (null if there is no current request).
        this._currentQueryDeferred = null;

        // deferred which is resolved when the *next* device query resolves.
        //
        // Normally it is meaningless for this to be non-null when
        // _currentQueryDeferred is null, but it can happen if the previous
        // query has finished but the next one has not yet started (because the
        // previous query failed, in which case we deliberately delay starting
        // the next query to avoid tight-looping).
        this._queuedQueryDeferred = null;

        this.lastKnownSyncToken = null;
    }

    /**
     * Download the keys for a list of users and stores the keys in the session
     * store.
     * @param {Array} userIds The users to fetch.
     * @param {bool} forceDownload Always download the keys even if cached.
     *
     * @return {Promise} A promise which resolves to a map userId->deviceId->{@link
     * module:crypto/deviceinfo|DeviceInfo}.
     */


    _createClass(DeviceList, [{
        key: 'downloadKeys',
        value: function downloadKeys(userIds, forceDownload) {
            var _this = this;

            var needsRefresh = false;
            var waitForCurrentQuery = false;

            userIds.forEach(function (u) {
                if (_this._pendingUsersWithNewDevices[u]) {
                    // we already know this user's devices are outdated
                    needsRefresh = true;
                } else if (_this._keyDownloadsInProgressByUser[u]) {
                    // already a download in progress - just wait for it.
                    // (even if forceDownload is true)
                    waitForCurrentQuery = true;
                } else if (forceDownload) {
                    console.log("Invalidating device list for " + u + " for forceDownload");
                    _this.invalidateUserDeviceList(u);
                    needsRefresh = true;
                } else if (!_this.getStoredDevicesForUser(u)) {
                    console.log("Invalidating device list for " + u + " due to empty cache");
                    _this.invalidateUserDeviceList(u);
                    needsRefresh = true;
                }
            });

            var promise = void 0;
            if (needsRefresh) {
                console.log("downloadKeys: waiting for next key query");
                promise = this._startOrQueueDeviceQuery();
            } else if (waitForCurrentQuery) {
                console.log("downloadKeys: waiting for in-flight query to complete");
                promise = this._currentQueryDeferred.promise;
            } else {
                // we're all up-to-date.
                promise = (0, _q2.default)();
            }

            return promise.then(function () {
                return _this._getDevicesFromStore(userIds);
            });
        }

        /**
         * Get the stored device keys for a list of user ids
         *
         * @param {string[]} userIds the list of users to list keys for.
         *
         * @return {Object} userId->deviceId->{@link module:crypto/deviceinfo|DeviceInfo}.
         */

    }, {
        key: '_getDevicesFromStore',
        value: function _getDevicesFromStore(userIds) {
            var stored = {};
            var self = this;
            userIds.map(function (u) {
                stored[u] = {};
                var devices = self.getStoredDevicesForUser(u) || [];
                devices.map(function (dev) {
                    stored[u][dev.deviceId] = dev;
                });
            });
            return stored;
        }

        /**
         * Get the stored device keys for a user id
         *
         * @param {string} userId the user to list keys for.
         *
         * @return {module:crypto/deviceinfo[]|null} list of devices, or null if we haven't
         * managed to get a list of devices for this user yet.
         */

    }, {
        key: 'getStoredDevicesForUser',
        value: function getStoredDevicesForUser(userId) {
            var devs = this._sessionStore.getEndToEndDevicesForUser(userId);
            if (!devs) {
                return null;
            }
            var res = [];
            for (var deviceId in devs) {
                if (devs.hasOwnProperty(deviceId)) {
                    res.push(_deviceinfo2.default.fromStorage(devs[deviceId], deviceId));
                }
            }
            return res;
        }

        /**
         * Get the stored keys for a single device
         *
         * @param {string} userId
         * @param {string} deviceId
         *
         * @return {module:crypto/deviceinfo?} device, or undefined
         * if we don't know about this device
         */

    }, {
        key: 'getStoredDevice',
        value: function getStoredDevice(userId, deviceId) {
            var devs = this._sessionStore.getEndToEndDevicesForUser(userId);
            if (!devs || !devs[deviceId]) {
                return undefined;
            }
            return _deviceinfo2.default.fromStorage(devs[deviceId], deviceId);
        }

        /**
         * Find a device by curve25519 identity key
         *
         * @param {string} userId     owner of the device
         * @param {string} algorithm  encryption algorithm
         * @param {string} senderKey  curve25519 key to match
         *
         * @return {module:crypto/deviceinfo?}
         */

    }, {
        key: 'getDeviceByIdentityKey',
        value: function getDeviceByIdentityKey(userId, algorithm, senderKey) {
            if (algorithm !== _olmlib2.default.OLM_ALGORITHM && algorithm !== _olmlib2.default.MEGOLM_ALGORITHM) {
                // we only deal in olm keys
                return null;
            }

            var devices = this._sessionStore.getEndToEndDevicesForUser(userId);
            if (!devices) {
                return null;
            }

            for (var deviceId in devices) {
                if (!devices.hasOwnProperty(deviceId)) {
                    continue;
                }

                var device = devices[deviceId];
                for (var keyId in device.keys) {
                    if (!device.keys.hasOwnProperty(keyId)) {
                        continue;
                    }
                    if (keyId.indexOf("curve25519:") !== 0) {
                        continue;
                    }
                    var deviceKey = device.keys[keyId];
                    if (deviceKey == senderKey) {
                        return _deviceinfo2.default.fromStorage(device, deviceId);
                    }
                }
            }

            // doesn't match a known device
            return null;
        }

        /**
         * Mark the cached device list for the given user outdated.
         *
         * This doesn't set off an update, so that several users can be batched
         * together. Call refreshOutdatedDeviceLists() for that.
         *
         * @param {String} userId
         */

    }, {
        key: 'invalidateUserDeviceList',
        value: function invalidateUserDeviceList(userId) {
            // sanity-check the userId. This is mostly paranoia, but if synapse
            // can't parse the userId we give it as an mxid, it 500s the whole
            // request and we can never update the device lists again (because
            // the broken userId is always 'invalid' and always included in any
            // refresh request).
            // By checking it is at least a string, we can eliminate a class of
            // silly errors.
            if (typeof userId !== 'string') {
                throw new Error('userId must be a string; was ' + userId);
            }
            this._pendingUsersWithNewDevices[userId] = true;
        }

        /**
         * If there is not already a device list query in progress, and we have
         * users who have outdated device lists, start a query now.
         */

    }, {
        key: 'refreshOutdatedDeviceLists',
        value: function refreshOutdatedDeviceLists() {
            if (this._currentQueryDeferred) {
                // request already in progress - do nothing. (We will automatically
                // make another request if there are more users with outdated
                // device lists when the current request completes).
                return;
            }

            this._startDeviceQuery();
        }

        /**
         * If there is currently a device list query in progress, returns a promise
         * which will resolve when the *next* query completes. Otherwise, starts
         * a new query, and returns a promise which resolves when it completes.
         *
         * @return {Promise}
         */

    }, {
        key: '_startOrQueueDeviceQuery',
        value: function _startOrQueueDeviceQuery() {
            if (!this._currentQueryDeferred) {
                this._startDeviceQuery();
                if (!this._currentQueryDeferred) {
                    return (0, _q2.default)();
                }

                return this._currentQueryDeferred.promise;
            }

            if (!this._queuedQueryDeferred) {
                this._queuedQueryDeferred = _q2.default.defer();
            }

            return this._queuedQueryDeferred.promise;
        }

        /**
         * kick off a new device query
         *
         * Throws if there is already a query in progress.
         */

    }, {
        key: '_startDeviceQuery',
        value: function _startDeviceQuery() {
            var _this2 = this;

            if (this._currentQueryDeferred) {
                throw new Error("DeviceList._startDeviceQuery called with request active");
            }

            this._currentQueryDeferred = this._queuedQueryDeferred || _q2.default.defer();
            this._queuedQueryDeferred = null;

            var users = Object.keys(this._pendingUsersWithNewDevices);
            if (users.length === 0) {
                // nothing to do
                this._currentQueryDeferred.resolve();
                this._currentQueryDeferred = null;

                // that means we're up-to-date with the lastKnownSyncToken.
                var token = this.lastKnownSyncToken;
                if (token !== null) {
                    this._sessionStore.storeEndToEndDeviceSyncToken(token);
                }

                return;
            }

            this._doKeyDownloadForUsers(users).done(function () {
                users.forEach(function (u) {
                    delete _this2._keyDownloadsInProgressByUser[u];
                });

                _this2._currentQueryDeferred.resolve();
                _this2._currentQueryDeferred = null;

                // flush out any more requests that were blocked up while that
                // was going on.
                _this2._startDeviceQuery();
            }, function (e) {
                console.error('Error updating device key cache for ' + users + ":", e);

                // reinstate the pending flags on any users which failed; this will
                // mean that we will do another download in the future (actually on
                // the next /sync).
                users.forEach(function (u) {
                    delete _this2._keyDownloadsInProgressByUser[u];
                    _this2._pendingUsersWithNewDevices[u] = true;
                });

                _this2._currentQueryDeferred.reject(e);
                _this2._currentQueryDeferred = null;
            });

            users.forEach(function (u) {
                delete _this2._pendingUsersWithNewDevices[u];
                _this2._keyDownloadsInProgressByUser[u] = true;
            });
        }

        /**
         * @param {string[]} downloadUsers list of userIds
         *
         * @return {Promise}
         */

    }, {
        key: '_doKeyDownloadForUsers',
        value: function _doKeyDownloadForUsers(downloadUsers) {
            var _this3 = this;

            console.log('Starting key download for ' + downloadUsers);

            var token = this.lastKnownSyncToken;
            var opts = {};
            if (token) {
                opts.token = token;
            }
            return this._baseApis.downloadKeysForUsers(downloadUsers, opts).then(function (res) {
                var dk = res.device_keys || {};

                // do each user in a separate promise, to avoid wedging the CPU
                // (https://github.com/vector-im/riot-web/issues/3158)
                //
                // of course we ought to do this in a web worker or similar, but
                // this serves as an easy solution for now.
                var prom = (0, _q2.default)();
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    var _loop = function _loop() {
                        var userId = _step.value;

                        prom = prom.delay(5).then(function () {
                            _this3._processQueryResponseForUser(userId, dk[userId]);
                        });
                    };

                    for (var _iterator = downloadUsers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        _loop();
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return prom;
            }).then(function () {
                if (token !== null) {
                    _this3._sessionStore.storeEndToEndDeviceSyncToken(token);
                }
                console.log('Completed key download for ' + downloadUsers);
            });
        }
    }, {
        key: '_processQueryResponseForUser',
        value: function _processQueryResponseForUser(userId, response) {
            console.log('got keys for ' + userId + ':', response);

            // map from deviceid -> deviceinfo for this user
            var userStore = {};
            var devs = this._sessionStore.getEndToEndDevicesForUser(userId);
            if (devs) {
                Object.keys(devs).forEach(function (deviceId) {
                    var d = _deviceinfo2.default.fromStorage(devs[deviceId], deviceId);
                    userStore[deviceId] = d;
                });
            }

            _updateStoredDeviceKeysForUser(this._olmDevice, userId, userStore, response || {});

            // update the session store
            var storage = {};
            Object.keys(userStore).forEach(function (deviceId) {
                storage[deviceId] = userStore[deviceId].toStorage();
            });

            this._sessionStore.storeEndToEndDevicesForUser(userId, storage);
        }
    }]);

    return DeviceList;
}();

exports.default = DeviceList;


function _updateStoredDeviceKeysForUser(_olmDevice, userId, userStore, userResult) {
    var updated = false;

    // remove any devices in the store which aren't in the response
    for (var deviceId in userStore) {
        if (!userStore.hasOwnProperty(deviceId)) {
            continue;
        }

        if (!(deviceId in userResult)) {
            console.log("Device " + userId + ":" + deviceId + " has been removed");
            delete userStore[deviceId];
            updated = true;
        }
    }

    for (var _deviceId in userResult) {
        if (!userResult.hasOwnProperty(_deviceId)) {
            continue;
        }

        var deviceResult = userResult[_deviceId];

        // check that the user_id and device_id in the response object are
        // correct
        if (deviceResult.user_id !== userId) {
            console.warn("Mismatched user_id " + deviceResult.user_id + " in keys from " + userId + ":" + _deviceId);
            continue;
        }
        if (deviceResult.device_id !== _deviceId) {
            console.warn("Mismatched device_id " + deviceResult.device_id + " in keys from " + userId + ":" + _deviceId);
            continue;
        }

        if (_storeDeviceKeys(_olmDevice, userStore, deviceResult)) {
            updated = true;
        }
    }

    return updated;
}

/*
 * Process a device in a /query response, and add it to the userStore
 *
 * returns true if a change was made, else false
 */
function _storeDeviceKeys(_olmDevice, userStore, deviceResult) {
    if (!deviceResult.keys) {
        // no keys?
        return false;
    }

    var deviceId = deviceResult.device_id;
    var userId = deviceResult.user_id;

    var signKeyId = "ed25519:" + deviceId;
    var signKey = deviceResult.keys[signKeyId];
    if (!signKey) {
        console.warn("Device " + userId + ":" + deviceId + " has no ed25519 key");
        return false;
    }

    var unsigned = deviceResult.unsigned || {};

    try {
        _olmlib2.default.verifySignature(_olmDevice, deviceResult, userId, deviceId, signKey);
    } catch (e) {
        console.warn("Unable to verify signature on device " + userId + ":" + deviceId + ":" + e);
        return false;
    }

    // DeviceInfo
    var deviceStore = void 0;

    if (deviceId in userStore) {
        // already have this device.
        deviceStore = userStore[deviceId];

        if (deviceStore.getFingerprint() != signKey) {
            // this should only happen if the list has been MITMed; we are
            // best off sticking with the original keys.
            //
            // Should we warn the user about it somehow?
            console.warn("Ed25519 key for device " + userId + ":" + deviceId + " has changed");
            return false;
        }
    } else {
        userStore[deviceId] = deviceStore = new _deviceinfo2.default(deviceId);
    }

    deviceStore.keys = deviceResult.keys || {};
    deviceStore.algorithms = deviceResult.algorithms || [];
    deviceStore.unsigned = unsigned;
    return true;
}
//# sourceMappingURL=DeviceList.js.map