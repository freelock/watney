{"version":3,"sources":["../../../src/crypto/algorithms/olm.js"],"names":["q","require","utils","olmlib","DeviceInfo","DeviceVerification","base","OlmEncryption","params","EncryptionAlgorithm","call","_sessionPrepared","_prepPromise","inherits","prototype","_ensureSession","roomMembers","self","_crypto","downloadKeys","then","res","ensureOlmSessionsForUsers","finally","encryptMessage","room","eventType","content","users","map","getJoinedMembers","u","userId","payloadFields","room_id","roomId","type","encryptedContent","algorithm","OLM_ALGORITHM","sender_key","_olmDevice","deviceCurve25519Key","ciphertext","i","length","devices","getStoredDevicesForUser","j","deviceInfo","key","getIdentityKey","verified","BLOCKED","encryptMessageForDevice","_userId","_deviceId","OlmDecryption","DecryptionAlgorithm","decryptEvent","event","getWireContent","deviceKey","DecryptionError","message","payloadString","_decryptMessage","e","console","warn","getId","payload","JSON","parse","recipient","recipient_keys","ed25519","deviceEd25519Key","sender","getSender","getRoomId","setClearData","curve25519","keys","theirDeviceIdentityKey","sessionIds","getSessionIdsForDevice","decryptionErrors","sessionId","decryptMessage","body","log","foundSession","matchesSession","Error","stringify","createInboundSession","session_id","registerAlgorithm"],"mappings":"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","file":"olm.js","sourcesContent":["/*\nCopyright 2016 OpenMarket Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\"use strict\";\n\n/**\n * Defines m.olm encryption/decryption\n *\n * @module crypto/algorithms/olm\n */\nconst q = require('q');\n\nconst utils = require(\"../../utils\");\nconst olmlib = require(\"../olmlib\");\nconst DeviceInfo = require(\"../deviceinfo\");\nconst DeviceVerification = DeviceInfo.DeviceVerification;\n\n\nconst base = require(\"./base\");\n\n/**\n * Olm encryption implementation\n *\n * @constructor\n * @extends {module:crypto/algorithms/base.EncryptionAlgorithm}\n *\n * @param {object} params parameters, as per\n *     {@link module:crypto/algorithms/base.EncryptionAlgorithm}\n */\nfunction OlmEncryption(params) {\n    base.EncryptionAlgorithm.call(this, params);\n    this._sessionPrepared = false;\n    this._prepPromise = null;\n}\nutils.inherits(OlmEncryption, base.EncryptionAlgorithm);\n\n/**\n * @private\n\n * @param {string[]} roomMembers list of currently-joined users in the room\n * @return {module:client.Promise} Promise which resolves when setup is complete\n */\nOlmEncryption.prototype._ensureSession = function(roomMembers) {\n    if (this._prepPromise) {\n        // prep already in progress\n        return this._prepPromise;\n    }\n\n    if (this._sessionPrepared) {\n        // prep already done\n        return q();\n    }\n\n    const self = this;\n    this._prepPromise = self._crypto.downloadKeys(roomMembers, true).then(function(res) {\n        return self._crypto.ensureOlmSessionsForUsers(roomMembers);\n    }).then(function() {\n        self._sessionPrepared = true;\n    }).finally(function() {\n        self._prepPromise = null;\n    });\n    return this._prepPromise;\n};\n\n/**\n * @inheritdoc\n *\n * @param {module:models/room} room\n * @param {string} eventType\n * @param {object} content plaintext event content\n *\n * @return {module:client.Promise} Promise which resolves to the new event body\n */\nOlmEncryption.prototype.encryptMessage = function(room, eventType, content) {\n    // pick the list of recipients based on the membership list.\n    //\n    // TODO: there is a race condition here! What if a new user turns up\n    // just as you are sending a secret message?\n\n    const users = utils.map(room.getJoinedMembers(), function(u) {\n        return u.userId;\n    });\n\n    const self = this;\n    return this._ensureSession(users).then(function() {\n        const payloadFields = {\n            room_id: room.roomId,\n            type: eventType,\n            content: content,\n        };\n\n        const encryptedContent = {\n            algorithm: olmlib.OLM_ALGORITHM,\n            sender_key: self._olmDevice.deviceCurve25519Key,\n            ciphertext: {},\n        };\n\n        for (let i = 0; i < users.length; ++i) {\n            const userId = users[i];\n            const devices = self._crypto.getStoredDevicesForUser(userId);\n\n            for (let j = 0; j < devices.length; ++j) {\n                const deviceInfo = devices[j];\n                const key = deviceInfo.getIdentityKey();\n                if (key == self._olmDevice.deviceCurve25519Key) {\n                    // don't bother sending to ourself\n                    continue;\n                }\n                if (deviceInfo.verified == DeviceVerification.BLOCKED) {\n                    // don't bother setting up sessions with blocked users\n                    continue;\n                }\n\n                olmlib.encryptMessageForDevice(\n                    encryptedContent.ciphertext,\n                    self._userId, self._deviceId, self._olmDevice,\n                    userId, deviceInfo, payloadFields,\n                );\n            }\n        }\n\n        return encryptedContent;\n    });\n};\n\n/**\n * Olm decryption implementation\n *\n * @constructor\n * @extends {module:crypto/algorithms/base.DecryptionAlgorithm}\n * @param {object} params parameters, as per\n *     {@link module:crypto/algorithms/base.DecryptionAlgorithm}\n */\nfunction OlmDecryption(params) {\n    base.DecryptionAlgorithm.call(this, params);\n}\nutils.inherits(OlmDecryption, base.DecryptionAlgorithm);\n\n/**\n * @inheritdoc\n *\n * @param {MatrixEvent} event\n *\n * @throws {module:crypto/algorithms/base.DecryptionError} if there is a\n *   problem decrypting the event\n */\nOlmDecryption.prototype.decryptEvent = function(event) {\n    const content = event.getWireContent();\n    const deviceKey = content.sender_key;\n    const ciphertext = content.ciphertext;\n\n    if (!ciphertext) {\n        throw new base.DecryptionError(\"Missing ciphertext\");\n    }\n\n    if (!(this._olmDevice.deviceCurve25519Key in ciphertext)) {\n        throw new base.DecryptionError(\"Not included in recipients\");\n    }\n    const message = ciphertext[this._olmDevice.deviceCurve25519Key];\n    let payloadString;\n\n    try {\n        payloadString = this._decryptMessage(deviceKey, message);\n    } catch (e) {\n        console.warn(\n            \"Failed to decrypt Olm event (id=\" +\n                event.getId() + \") from \" + deviceKey +\n                \": \" + e.message,\n        );\n        throw new base.DecryptionError(\"Bad Encrypted Message\");\n    }\n\n    const payload = JSON.parse(payloadString);\n\n    // check that we were the intended recipient, to avoid unknown-key attack\n    // https://github.com/vector-im/vector-web/issues/2483\n    if (payload.recipient != this._userId) {\n        console.warn(\n            \"Event \" + event.getId() + \": Intended recipient \" +\n            payload.recipient + \" does not match our id \" + this._userId,\n        );\n        throw new base.DecryptionError(\n            \"Message was intented for \" + payload.recipient,\n        );\n    }\n\n    if (payload.recipient_keys.ed25519 !=\n               this._olmDevice.deviceEd25519Key) {\n        console.warn(\n            \"Event \" + event.getId() + \": Intended recipient ed25519 key \" +\n            payload.recipient_keys.ed25519 + \" did not match ours\",\n        );\n        throw new base.DecryptionError(\"Message not intended for this device\");\n    }\n\n    // check that the original sender matches what the homeserver told us, to\n    // avoid people masquerading as others.\n    // (this check is also provided via the sender's embedded ed25519 key,\n    // which is checked elsewhere).\n    if (payload.sender != event.getSender()) {\n        console.warn(\n            \"Event \" + event.getId() + \": original sender \" + payload.sender +\n            \" does not match reported sender \" + event.getSender(),\n        );\n        throw new base.DecryptionError(\n            \"Message forwarded from \" + payload.sender,\n        );\n    }\n\n    // Olm events intended for a room have a room_id.\n    if (payload.room_id !== event.getRoomId()) {\n        console.warn(\n            \"Event \" + event.getId() + \": original room \" + payload.room_id +\n            \" does not match reported room \" + event.room_id,\n        );\n        throw new base.DecryptionError(\n            \"Message intended for room \" + payload.room_id,\n        );\n    }\n\n    event.setClearData(payload, {curve25519: deviceKey}, payload.keys || {});\n};\n\n\n/**\n * Attempt to decrypt an Olm message\n *\n * @param {string} theirDeviceIdentityKey  Curve25519 identity key of the sender\n * @param {object} message  message object, with 'type' and 'body' fields\n *\n * @return {string} payload, if decrypted successfully.\n */\nOlmDecryption.prototype._decryptMessage = function(theirDeviceIdentityKey, message) {\n    const sessionIds = this._olmDevice.getSessionIdsForDevice(theirDeviceIdentityKey);\n\n    // try each session in turn.\n    const decryptionErrors = {};\n    for (let i = 0; i < sessionIds.length; i++) {\n        const sessionId = sessionIds[i];\n        try {\n            const payload = this._olmDevice.decryptMessage(\n                theirDeviceIdentityKey, sessionId, message.type, message.body,\n            );\n            console.log(\n                \"Decrypted Olm message from \" + theirDeviceIdentityKey +\n                    \" with session \" + sessionId,\n            );\n            return payload;\n        } catch (e) {\n            const foundSession = this._olmDevice.matchesSession(\n                theirDeviceIdentityKey, sessionId, message.type, message.body,\n            );\n\n            if (foundSession) {\n                // decryption failed, but it was a prekey message matching this\n                // session, so it should have worked.\n                throw new Error(\n                    \"Error decrypting prekey message with existing session id \" +\n                        sessionId + \": \" + e.message,\n                );\n            }\n\n            // otherwise it's probably a message for another session; carry on, but\n            // keep a record of the error\n            decryptionErrors[sessionId] = e.message;\n        }\n    }\n\n    if (message.type !== 0) {\n        // not a prekey message, so it should have matched an existing session, but it\n        // didn't work.\n\n        if (sessionIds.length === 0) {\n            throw new Error(\"No existing sessions\");\n        }\n\n        throw new Error(\n            \"Error decrypting non-prekey message with existing sessions: \" +\n                JSON.stringify(decryptionErrors),\n        );\n    }\n\n    // prekey message which doesn't match any existing sessions: make a new\n    // session.\n\n    let res;\n    try {\n        res = this._olmDevice.createInboundSession(\n            theirDeviceIdentityKey, message.type, message.body,\n        );\n    } catch (e) {\n        decryptionErrors[\"(new)\"] = e.message;\n        throw new Error(\n            \"Error decrypting prekey message: \" +\n                JSON.stringify(decryptionErrors),\n        );\n    }\n\n    console.log(\n        \"created new inbound Olm session ID \" +\n            res.session_id + \" with \" + theirDeviceIdentityKey,\n    );\n    return res.payload;\n};\n\n\nbase.registerAlgorithm(olmlib.OLM_ALGORITHM, OlmEncryption, OlmDecryption);\n"]}