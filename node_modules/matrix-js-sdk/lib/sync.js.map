{"version":3,"sources":["../src/sync.js"],"names":["q","require","User","Room","utils","Filter","EventTimeline","DEBUG","BUFFER_PERIOD_MS","getFilterName","userId","suffix","debuglog","log","arguments","SyncApi","client","opts","initialSyncLimit","undefined","resolveInvitesToProfiles","pollTimeout","pendingEventOrdering","_peekRoomId","_currentSyncRequest","_syncState","_running","_keepAliveTimer","_connectionReturnedDefer","_notifEvents","getNotifTimelineSet","reEmit","prototype","createRoom","roomId","room","timelineSupport","_registerStateListeners","currentState","on","event","state","member","user","getUser","_deregisterStateListeners","removeAllListeners","syncLeftRooms","self","filter","credentials","setTimelineLimit","setIncludeLeaveRooms","localTimeoutMs","qps","timeout","getOrCreateFilter","then","filterId","_http","authedRequest","data","leaveRooms","rooms","leave","_mapSyncResponseToRoomArray","forEach","leaveObj","push","isBrandNewRoom","timeline","timelineEvents","_mapSyncEventsFormat","stateEvents","getLiveTimeline","setPaginationToken","prev_batch","BACKWARDS","_processRoomEvents","recalculate","store","storeRoom","emit","peek","roomInitialSync","response","messages","chunk","peekRoom","oldStateEvents","map","deepCopy","getEventMapper","presence","isArray","presenceEvent","getContent","user_id","setPresenceEvent","createNewUser","storeUser","start","oldState","paginationToken","setStateEvents","_resolveInvites","addEventsToTimeline","reverse","_peekPoll","stopPeeking","token","room_id","from","done","res","e","type","events","getRoom","addLiveEvents","end","err","console","error","setTimeout","getSyncState","sync","getSyncToken","global","document","_onOnlineBound","_onOnline","bind","addEventListener","getPushRules","result","pushRules","getFilter","_startKeepAlives","_updateSyncState","resetNotifTimelineSet","_sync","isGuest","stop","removeEventListener","abort","clearTimeout","retryImmediately","syncOptions","reject","_getGuestFilter","syncToken","since","_cacheBuster","Date","now","clientSideTimeoutMs","setSyncToken","next_batch","_processSyncResponse","stack","syncEventData","oldSyncToken","nextSyncToken","hasSyncedBefore","getSender","account_data","storeAccountDataEvents","accountDataEvent","getType","to_device","toDeviceEvent","content","msgtype","warn","body","inviteRooms","joinRooms","invite","join","inviteObj","invite_state","joinObj","ephemeralEvents","ephemeral","accountDataEvents","unread_notifications","setUnreadNotificationCount","notification_count","highlight_count","limited","i","length","eventId","getId","getTimelineForEvent","splice","resetLiveTimeline","addAccountData","sort","a","b","getTs","addLiveEvent","crypto","device_lists","changed","u","userDeviceListChanged","delay","Math","floor","random","_pokeKeepAlive","defer","promise","success","resolve","request","prefix","httpStatus","obj","keys","arrObj","mapper","getMembersWithMembership","_requestedProfileInfo","avatar_url","avatarUrl","displayname","displayName","getProfileInfo","info","inviteEvent","membership","setMembershipEvent","stateEventList","timelineEventList","mxEvent","pushActions","getPushActionsForEvent","notify","tweaks","highlight","guestRooms","_guestRooms","JSON","stringify","limit","newState","old","reEmitEntity","emittableEntity","eventNames","eventName","newArgs","module","exports"],"mappings":"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","file":"sync.js","sourcesContent":["/*\nCopyright 2015, 2016 OpenMarket Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\"use strict\";\n\n/*\n * TODO:\n * This class mainly serves to take all the syncing logic out of client.js and\n * into a separate file. It's all very fluid, and this class gut wrenches a lot\n * of MatrixClient props (e.g. _http). Given we want to support WebSockets as\n * an alternative syncing API, we may want to have a proper syncing interface\n * for HTTP and WS at some point.\n */\nconst q = require(\"q\");\nconst User = require(\"./models/user\");\nconst Room = require(\"./models/room\");\nconst utils = require(\"./utils\");\nconst Filter = require(\"./filter\");\nconst EventTimeline = require(\"./models/event-timeline\");\n\nconst DEBUG = true;\n\n// /sync requests allow you to set a timeout= but the request may continue\n// beyond that and wedge forever, so we need to track how long we are willing\n// to keep open the connection. This constant is *ADDED* to the timeout= value\n// to determine the max time we're willing to wait.\nconst BUFFER_PERIOD_MS = 80 * 1000;\n\nfunction getFilterName(userId, suffix) {\n    // scope this on the user ID because people may login on many accounts\n    // and they all need to be stored!\n    return \"FILTER_SYNC_\" + userId + (suffix ? \"_\" + suffix : \"\");\n}\n\nfunction debuglog() {\n    if (!DEBUG) {\n        return;\n    }\n    console.log(...arguments);\n}\n\n\n/**\n * <b>Internal class - unstable.</b>\n * Construct an entity which is able to sync with a homeserver.\n * @constructor\n * @param {MatrixClient} client The matrix client instance to use.\n * @param {Object} opts Config options\n * @param {module:crypto=} opts.crypto Crypto manager\n */\nfunction SyncApi(client, opts) {\n    this.client = client;\n    opts = opts || {};\n    opts.initialSyncLimit = (\n        opts.initialSyncLimit === undefined ? 8 : opts.initialSyncLimit\n    );\n    opts.resolveInvitesToProfiles = opts.resolveInvitesToProfiles || false;\n    opts.pollTimeout = opts.pollTimeout || (30 * 1000);\n    opts.pendingEventOrdering = opts.pendingEventOrdering || \"chronological\";\n    this.opts = opts;\n    this._peekRoomId = null;\n    this._currentSyncRequest = null;\n    this._syncState = null;\n    this._running = false;\n    this._keepAliveTimer = null;\n    this._connectionReturnedDefer = null;\n    this._notifEvents = []; // accumulator of sync events in the current sync response\n\n    if (client.getNotifTimelineSet()) {\n        reEmit(client, client.getNotifTimelineSet(),\n               [\"Room.timeline\", \"Room.timelineReset\"]);\n    }\n}\n\n/**\n * @param {string} roomId\n * @return {Room}\n */\nSyncApi.prototype.createRoom = function(roomId) {\n    const client = this.client;\n    const room = new Room(roomId, {\n        pendingEventOrdering: this.opts.pendingEventOrdering,\n        timelineSupport: client.timelineSupport,\n    });\n    reEmit(client, room, [\"Room.name\", \"Room.timeline\", \"Room.redaction\",\n                          \"Room.receipt\", \"Room.tags\",\n                          \"Room.timelineReset\",\n                          \"Room.localEchoUpdated\",\n                          \"Room.accountData\",\n                         ]);\n    this._registerStateListeners(room);\n    return room;\n};\n\n/**\n * @param {Room} room\n * @private\n */\nSyncApi.prototype._registerStateListeners = function(room) {\n    const client = this.client;\n    // we need to also re-emit room state and room member events, so hook it up\n    // to the client now. We need to add a listener for RoomState.members in\n    // order to hook them correctly. (TODO: find a better way?)\n    reEmit(client, room.currentState, [\n        \"RoomState.events\", \"RoomState.members\", \"RoomState.newMember\",\n    ]);\n    room.currentState.on(\"RoomState.newMember\", function(event, state, member) {\n        member.user = client.getUser(member.userId);\n        reEmit(\n            client, member,\n            [\n                \"RoomMember.name\", \"RoomMember.typing\", \"RoomMember.powerLevel\",\n                \"RoomMember.membership\",\n            ],\n        );\n    });\n};\n\n/**\n * @param {Room} room\n * @private\n */\nSyncApi.prototype._deregisterStateListeners = function(room) {\n    // could do with a better way of achieving this.\n    room.currentState.removeAllListeners(\"RoomState.events\");\n    room.currentState.removeAllListeners(\"RoomState.members\");\n    room.currentState.removeAllListeners(\"RoomState.newMember\");\n};\n\n\n/**\n * Sync rooms the user has left.\n * @return {Promise} Resolved when they've been added to the store.\n */\nSyncApi.prototype.syncLeftRooms = function() {\n    const client = this.client;\n    const self = this;\n\n    // grab a filter with limit=1 and include_leave=true\n    const filter = new Filter(this.client.credentials.userId);\n    filter.setTimelineLimit(1);\n    filter.setIncludeLeaveRooms(true);\n\n    const localTimeoutMs = this.opts.pollTimeout + BUFFER_PERIOD_MS;\n    const qps = {\n        timeout: 0, // don't want to block since this is a single isolated req\n    };\n\n    return client.getOrCreateFilter(\n        getFilterName(client.credentials.userId, \"LEFT_ROOMS\"), filter,\n    ).then(function(filterId) {\n        qps.filter = filterId;\n        return client._http.authedRequest(\n            undefined, \"GET\", \"/sync\", qps, undefined, localTimeoutMs,\n        );\n    }).then(function(data) {\n        let leaveRooms = [];\n        if (data.rooms && data.rooms.leave) {\n            leaveRooms = self._mapSyncResponseToRoomArray(data.rooms.leave);\n        }\n        const rooms = [];\n        leaveRooms.forEach(function(leaveObj) {\n            const room = leaveObj.room;\n            rooms.push(room);\n            if (!leaveObj.isBrandNewRoom) {\n                // the intention behind syncLeftRooms is to add in rooms which were\n                // *omitted* from the initial /sync. Rooms the user were joined to\n                // but then left whilst the app is running will appear in this list\n                // and we do not want to bother with them since they will have the\n                // current state already (and may get dupe messages if we add\n                // yet more timeline events!), so skip them.\n                // NB: When we persist rooms to localStorage this will be more\n                //     complicated...\n                return;\n            }\n            leaveObj.timeline = leaveObj.timeline || {};\n            const timelineEvents =\n                self._mapSyncEventsFormat(leaveObj.timeline, room);\n            const stateEvents = self._mapSyncEventsFormat(leaveObj.state, room);\n\n            // set the back-pagination token. Do this *before* adding any\n            // events so that clients can start back-paginating.\n            room.getLiveTimeline().setPaginationToken(leaveObj.timeline.prev_batch,\n                                                      EventTimeline.BACKWARDS);\n\n            self._processRoomEvents(room, stateEvents, timelineEvents);\n\n            room.recalculate(client.credentials.userId);\n            client.store.storeRoom(room);\n            client.emit(\"Room\", room);\n        });\n        return rooms;\n    });\n};\n\n/**\n * Peek into a room. This will result in the room in question being synced so it\n * is accessible via getRooms(). Live updates for the room will be provided.\n * @param {string} roomId The room ID to peek into.\n * @return {Promise} A promise which resolves once the room has been added to the\n * store.\n */\nSyncApi.prototype.peek = function(roomId) {\n    const self = this;\n    const client = this.client;\n    this._peekRoomId = roomId;\n    return this.client.roomInitialSync(roomId, 20).then(function(response) {\n        // make sure things are init'd\n        response.messages = response.messages || {};\n        response.messages.chunk = response.messages.chunk || [];\n        response.state = response.state || [];\n\n        const peekRoom = self.createRoom(roomId);\n\n        // FIXME: Mostly duplicated from _processRoomEvents but not entirely\n        // because \"state\" in this API is at the BEGINNING of the chunk\n        const oldStateEvents = utils.map(\n            utils.deepCopy(response.state), client.getEventMapper(),\n        );\n        const stateEvents = utils.map(\n            response.state, client.getEventMapper(),\n        );\n        const messages = utils.map(\n            response.messages.chunk, client.getEventMapper(),\n        );\n\n        // XXX: copypasted from /sync until we kill off this\n        // minging v1 API stuff)\n        // handle presence events (User objects)\n        if (response.presence && utils.isArray(response.presence)) {\n            response.presence.map(client.getEventMapper()).forEach(\n            function(presenceEvent) {\n                let user = client.store.getUser(presenceEvent.getContent().user_id);\n                if (user) {\n                    user.setPresenceEvent(presenceEvent);\n                } else {\n                    user = createNewUser(client, presenceEvent.getContent().user_id);\n                    user.setPresenceEvent(presenceEvent);\n                    client.store.storeUser(user);\n                }\n                client.emit(\"event\", presenceEvent);\n            });\n        }\n\n        // set the pagination token before adding the events in case people\n        // fire off pagination requests in response to the Room.timeline\n        // events.\n        if (response.messages.start) {\n            peekRoom.oldState.paginationToken = response.messages.start;\n        }\n\n        // set the state of the room to as it was after the timeline executes\n        peekRoom.oldState.setStateEvents(oldStateEvents);\n        peekRoom.currentState.setStateEvents(stateEvents);\n\n        self._resolveInvites(peekRoom);\n        peekRoom.recalculate(self.client.credentials.userId);\n\n        // roll backwards to diverge old state. addEventsToTimeline\n        // will overwrite the pagination token, so make sure it overwrites\n        // it with the right thing.\n        peekRoom.addEventsToTimeline(messages.reverse(), true,\n                                     peekRoom.getLiveTimeline(),\n                                     response.messages.start);\n\n        client.store.storeRoom(peekRoom);\n        client.emit(\"Room\", peekRoom);\n\n        self._peekPoll(roomId);\n        return peekRoom;\n    });\n};\n\n/**\n * Stop polling for updates in the peeked room. NOPs if there is no room being\n * peeked.\n */\nSyncApi.prototype.stopPeeking = function() {\n    this._peekRoomId = null;\n};\n\n/**\n * Do a peek room poll.\n * @param {string} roomId\n * @param {string} token from= token\n */\nSyncApi.prototype._peekPoll = function(roomId, token) {\n    if (this._peekRoomId !== roomId) {\n        debuglog(\"Stopped peeking in room %s\", roomId);\n        return;\n    }\n\n    const self = this;\n    // FIXME: gut wrenching; hard-coded timeout values\n    this.client._http.authedRequest(undefined, \"GET\", \"/events\", {\n        room_id: roomId,\n        timeout: 30 * 1000,\n        from: token,\n    }, undefined, 50 * 1000).done(function(res) {\n        // We have a problem that we get presence both from /events and /sync\n        // however, /sync only returns presence for users in rooms\n        // you're actually joined to.\n        // in order to be sure to get presence for all of the users in the\n        // peeked room, we handle presence explicitly here. This may result\n        // in duplicate presence events firing for some users, which is a\n        // performance drain, but such is life.\n        // XXX: copypasted from /sync until we can kill this minging v1 stuff.\n\n        res.chunk.filter(function(e) {\n            return e.type === \"m.presence\";\n        }).map(self.client.getEventMapper()).forEach(function(presenceEvent) {\n            let user = self.client.store.getUser(presenceEvent.getContent().user_id);\n            if (user) {\n                user.setPresenceEvent(presenceEvent);\n            } else {\n                user = createNewUser(self.client, presenceEvent.getContent().user_id);\n                user.setPresenceEvent(presenceEvent);\n                self.client.store.storeUser(user);\n            }\n            self.client.emit(\"event\", presenceEvent);\n        });\n\n        // strip out events which aren't for the given room_id (e.g presence)\n        const events = res.chunk.filter(function(e) {\n            return e.room_id === roomId;\n        }).map(self.client.getEventMapper());\n        const room = self.client.getRoom(roomId);\n        room.addLiveEvents(events);\n        self._peekPoll(roomId, res.end);\n    }, function(err) {\n        console.error(\"[%s] Peek poll failed: %s\", roomId, err);\n        setTimeout(function() {\n            self._peekPoll(roomId, token);\n        }, 30 * 1000);\n    });\n};\n\n/**\n * Returns the current state of this sync object\n * @see module:client~MatrixClient#event:\"sync\"\n * @return {?String}\n */\nSyncApi.prototype.getSyncState = function() {\n    return this._syncState;\n};\n\n/**\n * Main entry point\n */\nSyncApi.prototype.sync = function() {\n    debuglog(\"SyncApi.sync: starting with sync token \" +\n             this.client.store.getSyncToken());\n\n    const client = this.client;\n    const self = this;\n\n    this._running = true;\n\n    if (global.document) {\n        this._onOnlineBound = this._onOnline.bind(this);\n        global.document.addEventListener(\"online\", this._onOnlineBound, false);\n    }\n\n    // We need to do one-off checks before we can begin the /sync loop.\n    // These are:\n    //   1) We need to get push rules so we can check if events should bing as we get\n    //      them from /sync.\n    //   2) We need to get/create a filter which we can use for /sync.\n\n    function getPushRules() {\n        client.getPushRules().done(function(result) {\n            debuglog(\"Got push rules\");\n            client.pushRules = result;\n            getFilter(); // Now get the filter\n        }, function(err) {\n            self._startKeepAlives().done(function() {\n                getPushRules();\n            });\n            self._updateSyncState(\"ERROR\", { error: err });\n        });\n    }\n\n    function getFilter() {\n        let filter;\n        if (self.opts.filter) {\n            filter = self.opts.filter;\n        } else {\n            filter = new Filter(client.credentials.userId);\n            filter.setTimelineLimit(self.opts.initialSyncLimit);\n        }\n\n        client.getOrCreateFilter(\n            getFilterName(client.credentials.userId), filter,\n        ).done(function(filterId) {\n            // reset the notifications timeline to prepare it to paginate from\n            // the current point in time.\n            // The right solution would be to tie /sync pagination tokens into\n            // /notifications API somehow.\n            client.resetNotifTimelineSet();\n\n            self._sync({ filterId: filterId });\n        }, function(err) {\n            self._startKeepAlives().done(function() {\n                getFilter();\n            });\n            self._updateSyncState(\"ERROR\", { error: err });\n        });\n    }\n\n    if (client.isGuest()) {\n        // no push rules for guests, no access to POST filter for guests.\n        self._sync({});\n    } else {\n        getPushRules();\n    }\n};\n\n/**\n * Stops the sync object from syncing.\n */\nSyncApi.prototype.stop = function() {\n    debuglog(\"SyncApi.stop\");\n    if (global.document) {\n        global.document.removeEventListener(\"online\", this._onOnlineBound, false);\n        this._onOnlineBound = undefined;\n    }\n    this._running = false;\n    if (this._currentSyncRequest) {\n        this._currentSyncRequest.abort();\n    }\n    if (this._keepAliveTimer) {\n        clearTimeout(this._keepAliveTimer);\n        this._keepAliveTimer = null;\n    }\n};\n\n/**\n * Retry a backed off syncing request immediately. This should only be used when\n * the user <b>explicitly</b> attempts to retry their lost connection.\n * @return {boolean} True if this resulted in a request being retried.\n */\nSyncApi.prototype.retryImmediately = function() {\n    if (!this._connectionReturnedDefer) {\n        return false;\n    }\n    this._startKeepAlives(0);\n    return true;\n};\n\n/**\n * Invoke me to do /sync calls\n * @param {Object} syncOptions\n * @param {string} syncOptions.filterId\n * @param {boolean} syncOptions.hasSyncedBefore\n */\nSyncApi.prototype._sync = function(syncOptions) {\n    const client = this.client;\n    const self = this;\n\n    if (!this._running) {\n        debuglog(\"Sync no longer running: exiting.\");\n        if (self._connectionReturnedDefer) {\n            self._connectionReturnedDefer.reject();\n            self._connectionReturnedDefer = null;\n        }\n        this._updateSyncState(\"STOPPED\");\n        return;\n    }\n\n    let filterId = syncOptions.filterId;\n    if (client.isGuest() && !filterId) {\n        filterId = this._getGuestFilter();\n    }\n\n    const syncToken = client.store.getSyncToken();\n\n    const qps = {\n        filter: filterId,\n        timeout: this.opts.pollTimeout,\n    };\n\n    if (syncToken) {\n        qps.since = syncToken;\n    } else {\n        // use a cachebuster for initialsyncs, to make sure that\n        // we don't get a stale sync\n        // (https://github.com/vector-im/vector-web/issues/1354)\n        qps._cacheBuster = Date.now();\n    }\n\n    if (this.getSyncState() == 'ERROR' || this.getSyncState() == 'RECONNECTING') {\n        // we think the connection is dead. If it comes back up, we won't know\n        // about it till /sync returns. If the timeout= is high, this could\n        // be a long time. Set it to 0 when doing retries so we don't have to wait\n        // for an event or a timeout before emiting the SYNCING event.\n        qps.timeout = 0;\n    }\n\n    // normal timeout= plus buffer time\n    const clientSideTimeoutMs = this.opts.pollTimeout + BUFFER_PERIOD_MS;\n\n    this._currentSyncRequest = client._http.authedRequest(\n        undefined, \"GET\", \"/sync\", qps, undefined, clientSideTimeoutMs,\n    );\n\n    this._currentSyncRequest.done(function(data) {\n        // set the sync token NOW *before* processing the events. We do this so\n        // if something barfs on an event we can skip it rather than constantly\n        // polling with the same token.\n        client.store.setSyncToken(data.next_batch);\n\n        try {\n            self._processSyncResponse(syncToken, data);\n        } catch (e) {\n            // log the exception with stack if we have it, else fall back\n            // to the plain description\n            console.error(\"Caught /sync error\", e.stack || e);\n        }\n\n        // emit synced events\n        const syncEventData = {\n            oldSyncToken: syncToken,\n            nextSyncToken: data.next_batch,\n        };\n\n        if (!syncOptions.hasSyncedBefore) {\n            self._updateSyncState(\"PREPARED\", syncEventData);\n            syncOptions.hasSyncedBefore = true;\n        }\n\n        // keep emitting SYNCING -> SYNCING for clients who want to do bulk updates\n        self._updateSyncState(\"SYNCING\", syncEventData);\n\n        self._sync(syncOptions);\n    }, function(err) {\n        if (!self._running) {\n            debuglog(\"Sync no longer running: exiting\");\n            if (self._connectionReturnedDefer) {\n                self._connectionReturnedDefer.reject();\n                self._connectionReturnedDefer = null;\n            }\n            self._updateSyncState(\"STOPPED\");\n            return;\n        }\n        console.error(\"/sync error %s\", err);\n        console.error(err);\n\n        debuglog(\"Starting keep-alive\");\n        // Note that we do *not* mark the sync connection as\n        // lost yet: we only do this if a keepalive poke\n        // fails, since long lived HTTP connections will\n        // go away sometimes and we shouldn't treat this as\n        // erroneous. We set the state to 'reconnecting'\n        // instead, so that clients can onserve this state\n        // if they wish.\n        self._startKeepAlives().done(function() {\n            self._sync(syncOptions);\n        });\n        self._currentSyncRequest = null;\n        self._updateSyncState(\"RECONNECTING\");\n    });\n};\n\n/**\n * Process data returned from a sync response and propagate it\n * into the model objects\n *\n * @param {string} syncToken the old next_batch token sent to this\n *    sync request.\n * @param {Object} data The response from /sync\n */\nSyncApi.prototype._processSyncResponse = function(syncToken, data) {\n    const client = this.client;\n    const self = this;\n\n    // data looks like:\n    // {\n    //    next_batch: $token,\n    //    presence: { events: [] },\n    //    account_data: { events: [] },\n    //    device_lists: { changed: [\"@user:server\", ... ]},\n    //    to_device: { events: [] },\n    //    rooms: {\n    //      invite: {\n    //        $roomid: {\n    //          invite_state: { events: [] }\n    //        }\n    //      },\n    //      join: {\n    //        $roomid: {\n    //          state: { events: [] },\n    //          timeline: { events: [], prev_batch: $token, limited: true },\n    //          ephemeral: { events: [] },\n    //          account_data: { events: [] },\n    //          unread_notifications: {\n    //              highlight_count: 0,\n    //              notification_count: 0,\n    //          }\n    //        }\n    //      },\n    //      leave: {\n    //        $roomid: {\n    //          state: { events: [] },\n    //          timeline: { events: [], prev_batch: $token }\n    //        }\n    //      }\n    //    },\n    // }\n\n    // TODO-arch:\n    // - Each event we pass through needs to be emitted via 'event', can we\n    //   do this in one place?\n    // - The isBrandNewRoom boilerplate is boilerplatey.\n\n    // handle presence events (User objects)\n    if (data.presence && utils.isArray(data.presence.events)) {\n        data.presence.events.map(client.getEventMapper()).forEach(\n        function(presenceEvent) {\n            let user = client.store.getUser(presenceEvent.getSender());\n            if (user) {\n                user.setPresenceEvent(presenceEvent);\n            } else {\n                user = createNewUser(client, presenceEvent.getSender());\n                user.setPresenceEvent(presenceEvent);\n                client.store.storeUser(user);\n            }\n            client.emit(\"event\", presenceEvent);\n        });\n    }\n\n    // handle non-room account_data\n    if (data.account_data && utils.isArray(data.account_data.events)) {\n        const events = data.account_data.events.map(client.getEventMapper());\n        client.store.storeAccountDataEvents(events);\n        events.forEach(\n            function(accountDataEvent) {\n                if (accountDataEvent.getType() == 'm.push_rules') {\n                    client.pushRules = accountDataEvent.getContent();\n                }\n                client.emit(\"accountData\", accountDataEvent);\n                return accountDataEvent;\n            },\n        );\n    }\n\n    // handle to-device events\n    if (data.to_device && utils.isArray(data.to_device.events)) {\n        data.to_device.events\n            .map(client.getEventMapper())\n            .forEach(\n                function(toDeviceEvent) {\n                    const content = toDeviceEvent.getContent();\n                    if (\n                        toDeviceEvent.getType() == \"m.room.message\" &&\n                            content.msgtype == \"m.bad.encrypted\"\n                    ) {\n                        console.warn(\n                            \"Unable to decrypt to-device event: \" + content.body,\n                        );\n                        return;\n                    }\n\n                    client.emit(\"toDeviceEvent\", toDeviceEvent);\n                },\n            );\n    }\n\n    // the returned json structure is a bit crap, so make it into a\n    // nicer form (array) after applying sanity to make sure we don't fail\n    // on missing keys (on the off chance)\n    let inviteRooms = [];\n    let joinRooms = [];\n    let leaveRooms = [];\n\n    if (data.rooms) {\n        if (data.rooms.invite) {\n            inviteRooms = this._mapSyncResponseToRoomArray(data.rooms.invite);\n        }\n        if (data.rooms.join) {\n            joinRooms = this._mapSyncResponseToRoomArray(data.rooms.join);\n        }\n        if (data.rooms.leave) {\n            leaveRooms = this._mapSyncResponseToRoomArray(data.rooms.leave);\n        }\n    }\n\n    this._notifEvents = [];\n\n    // Handle invites\n    inviteRooms.forEach(function(inviteObj) {\n        const room = inviteObj.room;\n        const stateEvents =\n            self._mapSyncEventsFormat(inviteObj.invite_state, room);\n        self._processRoomEvents(room, stateEvents);\n        if (inviteObj.isBrandNewRoom) {\n            room.recalculate(client.credentials.userId);\n            client.store.storeRoom(room);\n            client.emit(\"Room\", room);\n        }\n        stateEvents.forEach(function(e) {\n            client.emit(\"event\", e);\n        });\n    });\n\n    // Handle joins\n    joinRooms.forEach(function(joinObj) {\n        const room = joinObj.room;\n        const stateEvents = self._mapSyncEventsFormat(joinObj.state, room);\n        const timelineEvents = self._mapSyncEventsFormat(joinObj.timeline, room);\n        const ephemeralEvents = self._mapSyncEventsFormat(joinObj.ephemeral);\n        const accountDataEvents = self._mapSyncEventsFormat(joinObj.account_data);\n\n        // we do this first so it's correct when any of the events fire\n        if (joinObj.unread_notifications) {\n            room.setUnreadNotificationCount(\n                'total', joinObj.unread_notifications.notification_count,\n            );\n            room.setUnreadNotificationCount(\n                'highlight', joinObj.unread_notifications.highlight_count,\n            );\n        }\n\n        joinObj.timeline = joinObj.timeline || {};\n\n        if (joinObj.isBrandNewRoom) {\n            // set the back-pagination token. Do this *before* adding any\n            // events so that clients can start back-paginating.\n            room.getLiveTimeline().setPaginationToken(\n                joinObj.timeline.prev_batch, EventTimeline.BACKWARDS);\n        } else if (joinObj.timeline.limited) {\n            let limited = true;\n\n            // we've got a limited sync, so we *probably* have a gap in the\n            // timeline, so should reset. But we might have been peeking or\n            // paginating and already have some of the events, in which\n            // case we just want to append any subsequent events to the end\n            // of the existing timeline.\n            //\n            // This is particularly important in the case that we already have\n            // *all* of the events in the timeline - in that case, if we reset\n            // the timeline, we'll end up with an entirely empty timeline,\n            // which we'll try to paginate but not get any new events (which\n            // will stop us linking the empty timeline into the chain).\n            //\n            for (let i = timelineEvents.length - 1; i >= 0; i--) {\n                const eventId = timelineEvents[i].getId();\n                if (room.getTimelineForEvent(eventId)) {\n                    debuglog(\"Already have event \" + eventId + \" in limited \" +\n                             \"sync - not resetting\");\n                    limited = false;\n\n                    // we might still be missing some of the events before i;\n                    // we don't want to be adding them to the end of the\n                    // timeline because that would put them out of order.\n                    timelineEvents.splice(0, i);\n\n                    // XXX: there's a problem here if the skipped part of the\n                    // timeline modifies the state set in stateEvents, because\n                    // we'll end up using the state from stateEvents rather\n                    // than the later state from timelineEvents. We probably\n                    // need to wind stateEvents forward over the events we're\n                    // skipping.\n\n                    break;\n                }\n            }\n\n            if (limited) {\n                // save the old 'next_batch' token as the\n                // forward-pagination token for the previously-active\n                // timeline.\n                room.currentState.paginationToken = syncToken;\n                self._deregisterStateListeners(room);\n                room.resetLiveTimeline(joinObj.timeline.prev_batch);\n\n                // We have to assume any gap in any timeline is\n                // reason to stop incrementally tracking notifications and\n                // reset the timeline.\n                client.resetNotifTimelineSet();\n\n                self._registerStateListeners(room);\n            }\n        }\n\n        self._processRoomEvents(room, stateEvents, timelineEvents);\n\n        // XXX: should we be adding ephemeralEvents to the timeline?\n        // It feels like that for symmetry with room.addAccountData()\n        // there should be a room.addEphemeralEvents() or similar.\n        room.addLiveEvents(ephemeralEvents);\n\n        // we deliberately don't add accountData to the timeline\n        room.addAccountData(accountDataEvents);\n\n        room.recalculate(client.credentials.userId);\n        if (joinObj.isBrandNewRoom) {\n            client.store.storeRoom(room);\n            client.emit(\"Room\", room);\n        }\n        stateEvents.forEach(function(e) {\n            client.emit(\"event\", e);\n        });\n        timelineEvents.forEach(function(e) {\n            client.emit(\"event\", e);\n        });\n        ephemeralEvents.forEach(function(e) {\n            client.emit(\"event\", e);\n        });\n        accountDataEvents.forEach(function(e) {\n            client.emit(\"event\", e);\n        });\n    });\n\n    // Handle leaves (e.g. kicked rooms)\n    leaveRooms.forEach(function(leaveObj) {\n        const room = leaveObj.room;\n        const stateEvents =\n            self._mapSyncEventsFormat(leaveObj.state, room);\n        const timelineEvents =\n            self._mapSyncEventsFormat(leaveObj.timeline, room);\n        const accountDataEvents =\n            self._mapSyncEventsFormat(leaveObj.account_data);\n\n        self._processRoomEvents(room, stateEvents, timelineEvents);\n        room.addAccountData(accountDataEvents);\n\n        room.recalculate(client.credentials.userId);\n        if (leaveObj.isBrandNewRoom) {\n            client.store.storeRoom(room);\n            client.emit(\"Room\", room);\n        }\n\n        stateEvents.forEach(function(e) {\n            client.emit(\"event\", e);\n        });\n        timelineEvents.forEach(function(e) {\n            client.emit(\"event\", e);\n        });\n        accountDataEvents.forEach(function(e) {\n            client.emit(\"event\", e);\n        });\n    });\n\n    // update the notification timeline, if appropriate.\n    // we only do this for live events, as otherwise we can't order them sanely\n    // in the timeline relative to ones paginated in by /notifications.\n    // XXX: we could fix this by making EventTimeline support chronological\n    // ordering... but it doesn't, right now.\n    if (syncToken && this._notifEvents.length) {\n        this._notifEvents.sort(function(a, b) {\n            return a.getTs() - b.getTs();\n        });\n        this._notifEvents.forEach(function(event) {\n            client.getNotifTimelineSet().addLiveEvent(event);\n        });\n    }\n\n    // Handle device list updates\n    if (this.opts.crypto && data.device_lists && data.device_lists.changed) {\n        data.device_lists.changed.forEach((u) => {\n            this.opts.crypto.userDeviceListChanged(u);\n        });\n    }\n};\n\n/**\n * Starts polling the connectivity check endpoint\n * @param {number} delay How long to delay until the first poll.\n *        defaults to a short, randomised interval (to prevent\n *        tightlooping if /versions succeeds but /sync etc. fail).\n * @return {promise}\n */\nSyncApi.prototype._startKeepAlives = function(delay) {\n    if (delay === undefined) {\n        delay = 2000 + Math.floor(Math.random() * 5000);\n    }\n\n    if (this._keepAliveTimer !== null) {\n        clearTimeout(this._keepAliveTimer);\n    }\n    const self = this;\n    if (delay > 0) {\n        self._keepAliveTimer = setTimeout(\n            self._pokeKeepAlive.bind(self),\n            delay,\n        );\n    } else {\n        self._pokeKeepAlive();\n    }\n    if (!this._connectionReturnedDefer) {\n        this._connectionReturnedDefer = q.defer();\n    }\n    return this._connectionReturnedDefer.promise;\n};\n\n/**\n *\n */\nSyncApi.prototype._pokeKeepAlive = function() {\n    const self = this;\n    function success() {\n        clearTimeout(self._keepAliveTimer);\n        if (self._connectionReturnedDefer) {\n            self._connectionReturnedDefer.resolve();\n            self._connectionReturnedDefer = null;\n        }\n    }\n\n    this.client._http.request(\n        undefined, // callback\n        \"GET\", \"/_matrix/client/versions\",\n        undefined, // queryParams\n        undefined, // data\n        {\n            prefix: '',\n            localTimeoutMs: 15 * 1000,\n        },\n    ).done(function() {\n        success();\n    }, function(err) {\n        if (err.httpStatus == 400) {\n            // treat this as a success because the server probably just doesn't\n            // support /versions: point is, we're getting a response.\n            // We wait a short time though, just in case somehow the server\n            // is in a mode where it 400s /versions responses and sync etc.\n            // responses fail, this will mean we don't hammer in a loop.\n            self._keepAliveTimer = setTimeout(success, 2000);\n        } else {\n            self._keepAliveTimer = setTimeout(\n                self._pokeKeepAlive.bind(self),\n                5000 + Math.floor(Math.random() * 5000),\n            );\n            // A keepalive has failed, so we emit the\n            // error state (whether or not this is the\n            // first failure).\n            // Note we do this after setting the timer:\n            // this lets the unit tests advance the mock\n            // clock when the get the error.\n            self._updateSyncState(\"ERROR\", { error: err });\n        }\n    });\n};\n\n/**\n * @param {Object} obj\n * @return {Object[]}\n */\nSyncApi.prototype._mapSyncResponseToRoomArray = function(obj) {\n    // Maps { roomid: {stuff}, roomid: {stuff} }\n    // to\n    // [{stuff+Room+isBrandNewRoom}, {stuff+Room+isBrandNewRoom}]\n    const client = this.client;\n    const self = this;\n    return utils.keys(obj).map(function(roomId) {\n        const arrObj = obj[roomId];\n        let room = client.store.getRoom(roomId);\n        let isBrandNewRoom = false;\n        if (!room) {\n            room = self.createRoom(roomId);\n            isBrandNewRoom = true;\n        }\n        arrObj.room = room;\n        arrObj.isBrandNewRoom = isBrandNewRoom;\n        return arrObj;\n    });\n};\n\n/**\n * @param {Object} obj\n * @param {Room} room\n * @return {MatrixEvent[]}\n */\nSyncApi.prototype._mapSyncEventsFormat = function(obj, room) {\n    if (!obj || !utils.isArray(obj.events)) {\n        return [];\n    }\n    const mapper = this.client.getEventMapper();\n    return obj.events.map(function(e) {\n        if (room) {\n            e.room_id = room.roomId;\n        }\n        return mapper(e);\n    });\n};\n\n/**\n * @param {Room} room\n */\nSyncApi.prototype._resolveInvites = function(room) {\n    if (!room || !this.opts.resolveInvitesToProfiles) {\n        return;\n    }\n    const client = this.client;\n    // For each invited room member we want to give them a displayname/avatar url\n    // if they have one (the m.room.member invites don't contain this).\n    room.getMembersWithMembership(\"invite\").forEach(function(member) {\n        if (member._requestedProfileInfo) {\n            return;\n        }\n        member._requestedProfileInfo = true;\n        // try to get a cached copy first.\n        const user = client.getUser(member.userId);\n        let promise;\n        if (user) {\n            promise = q({\n                avatar_url: user.avatarUrl,\n                displayname: user.displayName,\n            });\n        } else {\n            promise = client.getProfileInfo(member.userId);\n        }\n        promise.done(function(info) {\n            // slightly naughty by doctoring the invite event but this means all\n            // the code paths remain the same between invite/join display name stuff\n            // which is a worthy trade-off for some minor pollution.\n            const inviteEvent = member.events.member;\n            if (inviteEvent.getContent().membership !== \"invite\") {\n                // between resolving and now they have since joined, so don't clobber\n                return;\n            }\n            inviteEvent.getContent().avatar_url = info.avatar_url;\n            inviteEvent.getContent().displayname = info.displayname;\n            // fire listeners\n            member.setMembershipEvent(inviteEvent, room.currentState);\n        }, function(err) {\n            // OH WELL.\n        });\n    });\n};\n\n/**\n * @param {Room} room\n * @param {MatrixEvent[]} stateEventList A list of state events. This is the state\n * at the *START* of the timeline list if it is supplied.\n * @param {MatrixEvent[]} [timelineEventList] A list of timeline events. Lower index\n * is earlier in time. Higher index is later.\n */\nSyncApi.prototype._processRoomEvents = function(room, stateEventList,\n                                                timelineEventList) {\n    timelineEventList = timelineEventList || [];\n    const client = this.client;\n    // \"old\" and \"current\" state are the same initially; they\n    // start diverging if the user paginates.\n    // We must deep copy otherwise membership changes in old state\n    // will leak through to current state!\n    const oldStateEvents = utils.map(\n        utils.deepCopy(\n            stateEventList.map(function(mxEvent) {\n                return mxEvent.event;\n            }),\n        ), client.getEventMapper(),\n    );\n    const stateEvents = stateEventList;\n\n    // set the state of the room to as it was before the timeline executes\n    //\n    // XXX: what if we've already seen (some of) the events in the timeline,\n    // and they modify some of the state set in stateEvents? In that case we'll\n    // end up with the state from stateEvents, instead of the more recent state\n    // from the timeline.\n    room.oldState.setStateEvents(oldStateEvents);\n    room.currentState.setStateEvents(stateEvents);\n\n    this._resolveInvites(room);\n\n    // recalculate the room name at this point as adding events to the timeline\n    // may make notifications appear which should have the right name.\n    room.recalculate(this.client.credentials.userId);\n\n    // gather our notifications into this._notifEvents\n    if (client.getNotifTimelineSet()) {\n        for (let i = 0; i < timelineEventList.length; i++) {\n            const pushActions = client.getPushActionsForEvent(timelineEventList[i]);\n            if (pushActions && pushActions.notify &&\n                pushActions.tweaks && pushActions.tweaks.highlight) {\n                this._notifEvents.push(timelineEventList[i]);\n            }\n        }\n    }\n\n    // execute the timeline events, this will begin to diverge the current state\n    // if the timeline has any state events in it.\n    room.addLiveEvents(timelineEventList);\n};\n\n/**\n * @return {string}\n */\nSyncApi.prototype._getGuestFilter = function() {\n    const guestRooms = this.client._guestRooms; // FIXME: horrible gut-wrenching\n    if (!guestRooms) {\n        return \"{}\";\n    }\n    // we just need to specify the filter inline if we're a guest because guests\n    // can't create filters.\n    return JSON.stringify({\n        room: {\n            timeline: {\n                limit: 20,\n            },\n        },\n    });\n};\n\n/**\n * Sets the sync state and emits an event to say so\n * @param {String} newState The new state string\n * @param {Object} data Object of additional data to emit in the event\n */\nSyncApi.prototype._updateSyncState = function(newState, data) {\n    const old = this._syncState;\n    this._syncState = newState;\n    this.client.emit(\"sync\", this._syncState, old, data);\n};\n\n/**\n * Event handler for the 'online' event\n * This event is generally unreliable and precise behaviour\n * varies between browsers, so we poll for connectivity too,\n * but this might help us reconnect a little faster.\n */\nSyncApi.prototype._onOnline = function() {\n    debuglog(\"Browser thinks we are back online\");\n    this._startKeepAlives(0);\n};\n\nfunction createNewUser(client, userId) {\n    const user = new User(userId);\n    reEmit(client, user, [\n        \"User.avatarUrl\", \"User.displayName\", \"User.presence\",\n        \"User.currentlyActive\", \"User.lastPresenceTs\",\n    ]);\n    return user;\n}\n\nfunction reEmit(reEmitEntity, emittableEntity, eventNames) {\n    utils.forEach(eventNames, function(eventName) {\n        // setup a listener on the entity (the Room, User, etc) for this event\n        emittableEntity.on(eventName, function() {\n            // take the args from the listener and reuse them, adding the\n            // event name to the arg list so it works with .emit()\n            // Transformation Example:\n            // listener on \"foo\" => function(a,b) { ... }\n            // Re-emit on \"thing\" => thing.emit(\"foo\", a, b)\n            const newArgs = [eventName];\n            for (let i = 0; i < arguments.length; i++) {\n                newArgs.push(arguments[i]);\n            }\n            reEmitEntity.emit(...newArgs);\n        });\n    });\n}\n\n/** */\nmodule.exports = SyncApi;\n"]}