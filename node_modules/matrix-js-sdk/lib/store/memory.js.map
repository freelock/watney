{"version":3,"sources":["../../src/store/memory.js"],"names":["utils","require","User","module","exports","MatrixInMemoryStore","opts","rooms","groups","users","syncToken","filters","accountData","localStorage","prototype","getSyncToken","setSyncToken","token","storeGroup","group","groupId","getGroup","getGroups","values","storeRoom","room","roomId","currentState","on","_onRoomMember","bind","self","getMembers","forEach","m","event","state","member","membership","user","userId","name","setDisplayName","events","setRawDisplayName","getDirectionalContent","displayname","getContent","avatar_url","setAvatarUrl","getRoom","getRooms","removeRoom","removeListener","getRoomSummaries","map","summary","storeUser","getUser","getUsers","scrollback","limit","storeEvents","toStart","storeFilter","filter","filterId","getFilter","getFilterIdByName","filterName","getItem","e","setFilterIdByName","setItem","storeAccountDataEvents","getType","getAccountData","eventType","setSyncData","syncData","resolve","wantsSave","save","startup","getSavedSync","getSavedSyncToken","deleteAllData"],"mappings":"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","file":"memory.js","sourcesContent":["/*\nCopyright 2015, 2016 OpenMarket Ltd\nCopyright 2017 Vector Creations Ltd\nCopyright 2018 New Vector Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\"use strict\";\n/**\n * This is an internal module. See {@link MatrixInMemoryStore} for the public class.\n * @module store/memory\n */\nconst utils = require(\"../utils\");\nconst User = require(\"../models/user\");\nimport Promise from 'bluebird';\n\n/**\n * Construct a new in-memory data store for the Matrix Client.\n * @constructor\n * @param {Object=} opts Config options\n * @param {LocalStorage} opts.localStorage The local storage instance to persist\n * some forms of data such as tokens. Rooms will NOT be stored.\n */\nmodule.exports.MatrixInMemoryStore = function MatrixInMemoryStore(opts) {\n    opts = opts || {};\n    this.rooms = {\n        // roomId: Room\n    };\n    this.groups = {\n        // groupId: Group\n    };\n    this.users = {\n        // userId: User\n    };\n    this.syncToken = null;\n    this.filters = {\n        // userId: {\n        //    filterId: Filter\n        // }\n    };\n    this.accountData = {\n        // type : content\n    };\n    this.localStorage = opts.localStorage;\n};\n\nmodule.exports.MatrixInMemoryStore.prototype = {\n\n    /**\n     * Retrieve the token to stream from.\n     * @return {string} The token or null.\n     */\n    getSyncToken: function() {\n        return this.syncToken;\n    },\n\n\n    /**\n     * Set the token to stream from.\n     * @param {string} token The token to stream from.\n     */\n    setSyncToken: function(token) {\n        this.syncToken = token;\n    },\n\n    /**\n     * Store the given room.\n     * @param {Group} group The group to be stored\n     */\n    storeGroup: function(group) {\n        this.groups[group.groupId] = group;\n    },\n\n    /**\n     * Retrieve a group by its group ID.\n     * @param {string} groupId The group ID.\n     * @return {Group} The group or null.\n     */\n    getGroup: function(groupId) {\n        return this.groups[groupId] || null;\n    },\n\n    /**\n     * Retrieve all known groups.\n     * @return {Group[]} A list of groups, which may be empty.\n     */\n    getGroups: function() {\n        return utils.values(this.groups);\n    },\n\n    /**\n     * Store the given room.\n     * @param {Room} room The room to be stored. All properties must be stored.\n     */\n    storeRoom: function(room) {\n        this.rooms[room.roomId] = room;\n        // add listeners for room member changes so we can keep the room member\n        // map up-to-date.\n        room.currentState.on(\"RoomState.members\", this._onRoomMember.bind(this));\n        // add existing members\n        const self = this;\n        room.currentState.getMembers().forEach(function(m) {\n            self._onRoomMember(null, room.currentState, m);\n        });\n    },\n\n    /**\n     * Called when a room member in a room being tracked by this store has been\n     * updated.\n     * @param {MatrixEvent} event\n     * @param {RoomState} state\n     * @param {RoomMember} member\n     */\n    _onRoomMember: function(event, state, member) {\n        if (member.membership === \"invite\") {\n            // We do NOT add invited members because people love to typo user IDs\n            // which would then show up in these lists (!)\n            return;\n        }\n\n        const user = this.users[member.userId] || new User(member.userId);\n        if (member.name) {\n            user.setDisplayName(member.name);\n            if (member.events.member) {\n                user.setRawDisplayName(\n                    member.events.member.getDirectionalContent().displayname,\n                );\n            }\n        }\n        if (member.events.member && member.events.member.getContent().avatar_url) {\n            user.setAvatarUrl(member.events.member.getContent().avatar_url);\n        }\n        this.users[user.userId] = user;\n    },\n\n    /**\n     * Retrieve a room by its' room ID.\n     * @param {string} roomId The room ID.\n     * @return {Room} The room or null.\n     */\n    getRoom: function(roomId) {\n        return this.rooms[roomId] || null;\n    },\n\n    /**\n     * Retrieve all known rooms.\n     * @return {Room[]} A list of rooms, which may be empty.\n     */\n    getRooms: function() {\n        return utils.values(this.rooms);\n    },\n\n    /**\n     * Permanently delete a room.\n     * @param {string} roomId\n     */\n    removeRoom: function(roomId) {\n        if (this.rooms[roomId]) {\n            this.rooms[roomId].removeListener(\"RoomState.members\", this._onRoomMember);\n        }\n        delete this.rooms[roomId];\n    },\n\n    /**\n     * Retrieve a summary of all the rooms.\n     * @return {RoomSummary[]} A summary of each room.\n     */\n    getRoomSummaries: function() {\n        return utils.map(utils.values(this.rooms), function(room) {\n            return room.summary;\n        });\n    },\n\n    /**\n     * Store a User.\n     * @param {User} user The user to store.\n     */\n    storeUser: function(user) {\n        this.users[user.userId] = user;\n    },\n\n    /**\n     * Retrieve a User by its' user ID.\n     * @param {string} userId The user ID.\n     * @return {User} The user or null.\n     */\n    getUser: function(userId) {\n        return this.users[userId] || null;\n    },\n\n    /**\n     * Retrieve all known users.\n     * @return {User[]} A list of users, which may be empty.\n     */\n    getUsers: function() {\n        return utils.values(this.users);\n    },\n\n    /**\n     * Retrieve scrollback for this room.\n     * @param {Room} room The matrix room\n     * @param {integer} limit The max number of old events to retrieve.\n     * @return {Array<Object>} An array of objects which will be at most 'limit'\n     * length and at least 0. The objects are the raw event JSON.\n     */\n    scrollback: function(room, limit) {\n        return [];\n    },\n\n    /**\n     * Store events for a room. The events have already been added to the timeline\n     * @param {Room} room The room to store events for.\n     * @param {Array<MatrixEvent>} events The events to store.\n     * @param {string} token The token associated with these events.\n     * @param {boolean} toStart True if these are paginated results.\n     */\n    storeEvents: function(room, events, token, toStart) {\n        // no-op because they've already been added to the room instance.\n    },\n\n    /**\n     * Store a filter.\n     * @param {Filter} filter\n     */\n    storeFilter: function(filter) {\n        if (!filter) {\n            return;\n        }\n        if (!this.filters[filter.userId]) {\n            this.filters[filter.userId] = {};\n        }\n        this.filters[filter.userId][filter.filterId] = filter;\n    },\n\n    /**\n     * Retrieve a filter.\n     * @param {string} userId\n     * @param {string} filterId\n     * @return {?Filter} A filter or null.\n     */\n    getFilter: function(userId, filterId) {\n        if (!this.filters[userId] || !this.filters[userId][filterId]) {\n            return null;\n        }\n        return this.filters[userId][filterId];\n    },\n\n    /**\n     * Retrieve a filter ID with the given name.\n     * @param {string} filterName The filter name.\n     * @return {?string} The filter ID or null.\n     */\n    getFilterIdByName: function(filterName) {\n        if (!this.localStorage) {\n            return null;\n        }\n        try {\n            return this.localStorage.getItem(\"mxjssdk_memory_filter_\" + filterName);\n        } catch (e) {}\n        return null;\n    },\n\n    /**\n     * Set a filter name to ID mapping.\n     * @param {string} filterName\n     * @param {string} filterId\n     */\n    setFilterIdByName: function(filterName, filterId) {\n        if (!this.localStorage) {\n            return;\n        }\n        try {\n            this.localStorage.setItem(\"mxjssdk_memory_filter_\" + filterName, filterId);\n        } catch (e) {}\n    },\n\n    /**\n     * Store user-scoped account data events.\n     * N.B. that account data only allows a single event per type, so multiple\n     * events with the same type will replace each other.\n     * @param {Array<MatrixEvent>} events The events to store.\n     */\n    storeAccountDataEvents: function(events) {\n        const self = this;\n        events.forEach(function(event) {\n            self.accountData[event.getType()] = event;\n        });\n    },\n\n    /**\n     * Get account data event by event type\n     * @param {string} eventType The event type being queried\n     * @return {?MatrixEvent} the user account_data event of given type, if any\n     */\n    getAccountData: function(eventType) {\n        return this.accountData[eventType];\n    },\n\n    /**\n     * setSyncData does nothing as there is no backing data store.\n     *\n     * @param {Object} syncData The sync data\n     * @return {Promise} An immediately resolved promise.\n     */\n    setSyncData: function(syncData) {\n        return Promise.resolve();\n    },\n\n    /**\n     * We never want to save becase we have nothing to save to.\n     *\n     * @return {boolean} If the store wants to save\n     */\n    wantsSave: function() {\n        return false;\n    },\n\n    /**\n     * Save does nothing as there is no backing data store.\n     */\n    save: function() {},\n\n    /**\n     * Startup does nothing as this store doesn't require starting up.\n     * @return {Promise} An immediately resolved promise.\n     */\n    startup: function() {\n        return Promise.resolve();\n    },\n\n    /**\n     * @return {Promise} Resolves with a sync response to restore the\n     * client state to where it was at the last save, or null if there\n     * is no saved sync data.\n     */\n    getSavedSync: function() {\n        return Promise.resolve(null);\n    },\n\n    /**\n     * @return {Promise} If there is a saved sync, the nextBatch token\n     * for this sync, otherwise null.\n     */\n    getSavedSyncToken: function() {\n        return Promise.resolve(null);\n    },\n\n    /**\n     * Delete all data from this store.\n     * @return {Promise} An immediately resolved promise.\n     */\n    deleteAllData: function() {\n        this.rooms = {\n            // roomId: Room\n        };\n        this.users = {\n            // userId: User\n        };\n        this.syncToken = null;\n        this.filters = {\n            // userId: {\n            //    filterId: Filter\n            // }\n        };\n        this.accountData = {\n            // type : content\n        };\n        return Promise.resolve();\n    },\n};\n"]}