diff --git a/lib/sync.js b/lib/sync.js
index f1581cd..454b37c 100644
--- a/lib/sync.js
+++ b/lib/sync.js
@@ -454,9 +454,20 @@ SyncApi.prototype.retryImmediately = function() {
  * Invoke me to do /sync calls
  * @param {Object} syncOptions
  * @param {string} syncOptions.filterId
+ * @param {integer} syncOptions.timeout Timeout parameter passed to the
+ *   sync call
+ * @param {integer} syncOptions.clientTimeout Time we wait for the sync
+ *   request to complete. This should be sufficiently larger  than
+ *   `timeout` that the server has time to return a request after
+ *   `timeout` without us timing it out first.
+ * @param {Object} oneTimeOptions As syncOptions, but these parameters
+ *   will only be applied to the first sync request made, and not
+ *   subsequent ones.
  * @param {boolean} syncOptions.hasSyncedBefore
  */
-SyncApi.prototype._sync = function(syncOptions) {
+SyncApi.prototype._sync = function(syncOptions, oneTimeOptions) {
+    var effectiveOptions = Object.assign({}, syncOptions, oneTimeOptions);
+
     var client = this.client;
     var self = this;
 
@@ -470,7 +481,7 @@ SyncApi.prototype._sync = function(syncOptions) {
         return;
     }
 
-    var filterId = syncOptions.filterId;
+    var filterId = effectiveOptions.filterId;
     if (client.isGuest() && !filterId) {
         filterId = this._getGuestFilter();
     }
@@ -524,9 +535,9 @@ SyncApi.prototype._sync = function(syncOptions) {
         }
 
         // emit synced events
-        if (!syncOptions.hasSyncedBefore) {
+        if (!effectiveOptions.hasSyncedBefore) {
             self._updateSyncState("PREPARED");
-            syncOptions.hasSyncedBefore = true;
+            effectiveOptions.hasSyncedBefore = true;
         }
 
         // keep emitting SYNCING -> SYNCING for clients who want to do bulk updates
